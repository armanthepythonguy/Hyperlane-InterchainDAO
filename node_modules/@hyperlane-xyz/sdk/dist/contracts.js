"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appFromAddressesMapHelper = exports.filterOwnableContracts = exports.connectContractsMap = exports.connectContracts = exports.attachContractsMap = exports.attachContracts = exports.filterAddressesMap = exports.serializeContracts = exports.serializeContractsMap = void 0;
const objects_1 = require("./utils/objects");
function serializeContractsMap(contractsMap) {
    return (0, objects_1.objMap)(contractsMap, (_, contracts) => {
        return serializeContracts(contracts);
    });
}
exports.serializeContractsMap = serializeContractsMap;
function serializeContracts(contracts) {
    return (0, objects_1.objMap)(contracts, (_, contract) => contract.address);
}
exports.serializeContracts = serializeContracts;
function getFactory(key, factories) {
    if (!(key in factories)) {
        throw new Error(`Factories entry missing for ${key.toString()}`);
    }
    return factories[key];
}
function filterAddressesMap(addressesMap, factories) {
    const factoryKeys = Object.keys(factories);
    // Filter out addresses that we do not have factories for
    const pickedAddressesMap = (0, objects_1.objMap)(addressesMap, (_, addresses) => (0, objects_1.pick)(addresses, factoryKeys));
    // Filter out chains for which we do not have a complete set of addresses
    return (0, objects_1.objFilter)(pickedAddressesMap, (_, addresses) => {
        return Object.keys(addresses).every((a) => factoryKeys.includes(a));
    });
}
exports.filterAddressesMap = filterAddressesMap;
function attachContracts(addresses, factories) {
    return (0, objects_1.objMap)(addresses, (key, address) => {
        const factory = getFactory(key, factories);
        return factory.attach(address);
    });
}
exports.attachContracts = attachContracts;
function attachContractsMap(addressesMap, factories) {
    const filteredAddressesMap = filterAddressesMap(addressesMap, factories);
    return (0, objects_1.objMap)(filteredAddressesMap, (_, addresses) => attachContracts(addresses, factories));
}
exports.attachContractsMap = attachContractsMap;
function connectContracts(contracts, connection) {
    return (0, objects_1.objMap)(contracts, (_, contract) => contract.connect(connection));
}
exports.connectContracts = connectContracts;
function connectContractsMap(contractsMap, multiProvider) {
    return (0, objects_1.objMap)(contractsMap, (chain, contracts) => connectContracts(contracts, multiProvider.getSignerOrProvider(chain)));
}
exports.connectContractsMap = connectContractsMap;
function filterOwnableContracts(contracts) {
    return __awaiter(this, void 0, void 0, function* () {
        const isOwnable = (_, contract) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield contract.owner();
                return true;
            }
            catch (_) {
                return false;
            }
        });
        const isOwnableContracts = yield (0, objects_1.promiseObjAll)((0, objects_1.objMap)(contracts, isOwnable));
        return (0, objects_1.objFilter)(contracts, (name, contract) => isOwnableContracts[name]);
    });
}
exports.filterOwnableContracts = filterOwnableContracts;
function appFromAddressesMapHelper(addressesMap, factories, multiProvider) {
    // Attaches contracts for each chain for which we have a complete set of
    // addresses
    const contractsMap = attachContractsMap(addressesMap, factories);
    // Filters out providers for chains for which we don't have a complete set
    // of addresses
    const intersection = multiProvider.intersect(Object.keys(contractsMap));
    // Filters out contracts for chains for which we don't have a provider
    const filteredContractsMap = (0, objects_1.pick)(contractsMap, intersection.intersection);
    return {
        contractsMap: filteredContractsMap,
        multiProvider: intersection.multiProvider,
    };
}
exports.appFromAddressesMapHelper = appFromAddressesMapHelper;
//# sourceMappingURL=contracts.js.map