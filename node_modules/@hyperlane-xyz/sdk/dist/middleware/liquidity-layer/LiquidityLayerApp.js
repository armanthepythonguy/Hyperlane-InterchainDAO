"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiquidityLayerApp = void 0;
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneApp_1 = require("../../HyperlaneApp");
const fetch_1 = require("../../utils/fetch");
const PORTAL_VAA_SERVICE_TESTNET_BASE_URL = 'https://wormhole-v2-testnet-api.certus.one/v1/signed_vaa/';
const CIRCLE_ATTESTATIONS_TESTNET_BASE_URL = 'https://iris-api-sandbox.circle.com/attestations/';
const CIRCLE_ATTESTATIONS_MAINNET_BASE_URL = 'https://iris-api.circle.com/attestations/';
const PORTAL_VAA_SERVICE_SUCCESS_CODE = 5;
const TokenMessengerInterface = core_1.ITokenMessenger__factory.createInterface();
const CircleBridgeAdapterInterface = core_1.CircleBridgeAdapter__factory.createInterface();
const PortalAdapterInterface = core_1.PortalAdapter__factory.createInterface();
const MailboxInterface = core_1.Mailbox__factory.createInterface();
const BridgedTokenTopic = CircleBridgeAdapterInterface.getEventTopic(CircleBridgeAdapterInterface.getEvent('BridgedToken'));
const PortalBridgedTokenTopic = PortalAdapterInterface.getEventTopic(PortalAdapterInterface.getEvent('BridgedToken'));
class LiquidityLayerApp extends HyperlaneApp_1.HyperlaneApp {
    constructor(contractsMap, multiProvider, config) {
        super(contractsMap, multiProvider);
        this.contractsMap = contractsMap;
        this.multiProvider = multiProvider;
        this.config = config;
    }
    fetchCircleMessageTransactions(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`Fetch circle messages for ${chain}`);
            const url = new URL(this.multiProvider.getExplorerApiUrl(chain));
            url.searchParams.set('module', 'logs');
            url.searchParams.set('action', 'getLogs');
            url.searchParams.set('address', this.getContracts(chain).circleBridgeAdapter.address);
            url.searchParams.set('topic0', BridgedTokenTopic);
            const req = yield (0, fetch_1.fetchWithTimeout)(url);
            const response = yield req.json();
            return response.result.map((tx) => tx.transactionHash).flat();
        });
    }
    fetchPortalBridgeTransactions(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = new URL(this.multiProvider.getExplorerApiUrl(chain));
            url.searchParams.set('module', 'logs');
            url.searchParams.set('action', 'getLogs');
            url.searchParams.set('address', this.getContracts(chain).portalAdapter.address);
            url.searchParams.set('topic0', PortalBridgedTokenTopic);
            const req = yield (0, fetch_1.fetchWithTimeout)(url);
            const response = yield req.json();
            if (!response.result) {
                throw Error(`Expected result in response: ${response}`);
            }
            return response.result.map((tx) => tx.transactionHash).flat();
        });
    }
    parsePortalMessages(chain, txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.multiProvider.getProvider(chain);
            const receipt = yield provider.getTransactionReceipt(txHash);
            const matchingLogs = receipt.logs
                .map((log) => {
                try {
                    return [PortalAdapterInterface.parseLog(log)];
                }
                catch (_a) {
                    return [];
                }
            })
                .flat();
            if (matchingLogs.length == 0)
                return [];
            const event = matchingLogs.find((log) => log.name === 'BridgedToken');
            const portalSequence = event.args.portalSequence.toNumber();
            const nonce = event.args.nonce.toNumber();
            const destination = this.multiProvider.getChainName(event.args.destination);
            return [{ origin: chain, nonce, portalSequence, destination }];
        });
    }
    parseCircleMessages(chain, txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            console.debug(`Parse Circle messages for chain ${chain} ${txHash}`);
            const provider = this.multiProvider.getProvider(chain);
            const receipt = yield provider.getTransactionReceipt(txHash);
            const matchingLogs = receipt.logs
                .map((log) => {
                try {
                    return [TokenMessengerInterface.parseLog(log)];
                }
                catch (_a) {
                    try {
                        return [CircleBridgeAdapterInterface.parseLog(log)];
                    }
                    catch (_b) {
                        try {
                            return [MailboxInterface.parseLog(log)];
                        }
                        catch (_c) {
                            return [];
                        }
                    }
                }
            })
                .flat();
            if (matchingLogs.length == 0)
                return [];
            const message = matchingLogs.find((log) => log.name === 'MessageSent')
                .args.message;
            const nonce = matchingLogs.find((log) => log.name === 'BridgedToken').args
                .nonce;
            const destinationDomain = matchingLogs.find((log) => log.name === 'Dispatch').args.destination;
            const remoteChain = this.multiProvider.getChainName(destinationDomain);
            const domain = this.config[chain].circle.circleDomainMapping.find((mapping) => mapping.hyperlaneDomain === this.multiProvider.getDomainId(chain)).circleDomain;
            return [
                {
                    chain,
                    remoteChain,
                    txHash,
                    message,
                    nonce,
                    domain,
                    nonceHash: ethers_1.ethers.utils.solidityKeccak256(['uint32', 'uint64'], [domain, nonce]),
                },
            ];
        });
    }
    attemptPortalTransferCompletion(message) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const destinationPortalAdapter = this.getContracts(message.destination)
                .portalAdapter;
            const transferId = yield destinationPortalAdapter.transferId(this.multiProvider.getDomainId(message.origin), message.nonce);
            const transferTokenAddress = yield destinationPortalAdapter.portalTransfersProcessed(transferId);
            if (!utils_1.utils.eqAddress(transferTokenAddress, ethers_1.ethers.constants.AddressZero)) {
                console.log(`Transfer with nonce ${message.nonce} from ${message.origin} to ${message.destination} already processed`);
                return;
            }
            const wormholeOriginDomain = (_a = this.config[message.destination].portal.wormholeDomainMapping.find((mapping) => mapping.hyperlaneDomain ===
                this.multiProvider.getDomainId(message.origin))) === null || _a === void 0 ? void 0 : _a.wormholeDomain;
            const emitter = utils_1.utils.strip0x(utils_1.utils.addressToBytes32(this.config[message.origin].portal.portalBridgeAddress));
            const vaa = yield (0, fetch_1.fetchWithTimeout)(`${PORTAL_VAA_SERVICE_TESTNET_BASE_URL}${wormholeOriginDomain}/${emitter}/${message.portalSequence}`).then((response) => response.json());
            if (vaa.code && vaa.code === PORTAL_VAA_SERVICE_SUCCESS_CODE) {
                console.log(`VAA not yet found for nonce ${message.nonce}`);
                return;
            }
            console.debug(`Complete portal transfer for nonce ${message.nonce} on ${message.destination}`);
            try {
                yield this.multiProvider.handleTx(message.destination, destinationPortalAdapter.completeTransfer(utils_1.utils.ensure0x(Buffer.from(vaa.vaaBytes, 'base64').toString('hex'))));
            }
            catch (error) {
                if ((_c = (_b = error === null || error === void 0 ? void 0 : error.error) === null || _b === void 0 ? void 0 : _b.reason) === null || _c === void 0 ? void 0 : _c.includes('no wrapper for this token')) {
                    console.log('No wrapper for this token, you should register the token at https://wormhole-foundation.github.io/example-token-bridge-ui/#/register');
                    console.log(message);
                    return;
                }
                throw error;
            }
        });
    }
    attemptCircleAttestationSubmission(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(message.remoteChain);
            const transmitter = core_1.ICircleMessageTransmitter__factory.connect(this.config[message.remoteChain].circle.messageTransmitterAddress, signer);
            const alreadyProcessed = yield transmitter.usedNonces(message.nonceHash);
            if (alreadyProcessed) {
                console.log(`Message sent on ${message.txHash} was already processed`);
                return;
            }
            console.log(`Attempt Circle message delivery`, JSON.stringify(message));
            const messageHash = ethers_1.ethers.utils.keccak256(message.message);
            const baseurl = this.multiProvider.getChainMetadata(message.chain).isTestnet
                ? CIRCLE_ATTESTATIONS_TESTNET_BASE_URL
                : CIRCLE_ATTESTATIONS_MAINNET_BASE_URL;
            const attestationsB = yield (0, fetch_1.fetchWithTimeout)(`${baseurl}${messageHash}`);
            const attestations = yield attestationsB.json();
            if (attestations.status !== 'complete') {
                console.log(`Attestations not available for message nonce ${message.nonce} on ${message.txHash}`);
                return;
            }
            console.log(`Ready to submit attestations for message ${message.nonce}`);
            const tx = yield transmitter.receiveMessage(message.message, attestations.attestation);
            console.log(`Submitted attestations in ${this.multiProvider.tryGetExplorerTxUrl(message.remoteChain, tx)}`);
            yield this.multiProvider.handleTx(message.remoteChain, tx);
        });
    }
}
exports.LiquidityLayerApp = LiquidityLayerApp;
//# sourceMappingURL=LiquidityLayerApp.js.map