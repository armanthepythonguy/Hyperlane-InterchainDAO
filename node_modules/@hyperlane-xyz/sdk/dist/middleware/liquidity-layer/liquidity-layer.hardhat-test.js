"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../../consts/chainMetadata");
const chains_1 = require("../../consts/chains");
const TestCoreApp_1 = require("../../core/TestCoreApp");
const TestCoreDeployer_1 = require("../../core/TestCoreDeployer");
const MultiProvider_1 = require("../../providers/MultiProvider");
const testUtils_1 = require("../../test/testUtils");
const objects_1 = require("../../utils/objects");
const LiquidityLayerApp_1 = require("./LiquidityLayerApp");
const LiquidityLayerRouterDeployer_1 = require("./LiquidityLayerRouterDeployer");
describe('LiquidityLayerRouter', () => __awaiter(void 0, void 0, void 0, function* () {
    const localChain = chains_1.Chains.test1;
    const remoteChain = chains_1.Chains.test2;
    const localDomain = chainMetadata_1.chainMetadata[localChain].chainId;
    const remoteDomain = chainMetadata_1.chainMetadata[remoteChain].chainId;
    let signer;
    let local;
    let multiProvider;
    let coreApp;
    let liquidityLayerApp;
    let config;
    let mockToken;
    let circleTokenMessenger;
    let portalBridge;
    let messageTransmitter;
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        [signer] = yield hardhat_1.ethers.getSigners();
        multiProvider = MultiProvider_1.MultiProvider.createTestMultiProvider({ signer });
        const coreDeployer = new TestCoreDeployer_1.TestCoreDeployer(multiProvider);
        const coreContractsMaps = yield coreDeployer.deploy();
        coreApp = new TestCoreApp_1.TestCoreApp(coreContractsMaps, multiProvider);
        const mockTokenF = new core_1.MockToken__factory(signer);
        mockToken = yield mockTokenF.deploy();
        const portalBridgeF = new core_1.MockPortalBridge__factory(signer);
        const circleTokenMessengerF = new core_1.MockCircleTokenMessenger__factory(signer);
        circleTokenMessenger = yield circleTokenMessengerF.deploy(mockToken.address);
        portalBridge = yield portalBridgeF.deploy(mockToken.address);
        const messageTransmitterF = new core_1.MockCircleMessageTransmitter__factory(signer);
        messageTransmitter = yield messageTransmitterF.deploy(mockToken.address);
        const routerConfig = yield (0, testUtils_1.deployTestIgpsAndGetRouterConfig)(multiProvider, signer.address, coreContractsMaps);
        config = (0, objects_1.objMap)(routerConfig, (chain, config) => {
            return Object.assign(Object.assign({}, config), { circle: {
                    type: LiquidityLayerRouterDeployer_1.BridgeAdapterType.Circle,
                    tokenMessengerAddress: circleTokenMessenger.address,
                    messageTransmitterAddress: messageTransmitter.address,
                    usdcAddress: mockToken.address,
                    circleDomainMapping: [
                        {
                            hyperlaneDomain: localDomain,
                            circleDomain: localDomain,
                        },
                        {
                            hyperlaneDomain: remoteDomain,
                            circleDomain: remoteDomain,
                        },
                    ],
                }, portal: {
                    type: LiquidityLayerRouterDeployer_1.BridgeAdapterType.Portal,
                    portalBridgeAddress: portalBridge.address,
                    wormholeDomainMapping: [
                        {
                            hyperlaneDomain: localDomain,
                            wormholeDomain: localDomain,
                        },
                        {
                            hyperlaneDomain: remoteDomain,
                            wormholeDomain: remoteDomain,
                        },
                    ],
                } });
        });
    }));
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const LiquidityLayer = new LiquidityLayerRouterDeployer_1.LiquidityLayerDeployer(multiProvider);
        const contracts = yield LiquidityLayer.deploy(config);
        liquidityLayerApp = new LiquidityLayerApp_1.LiquidityLayerApp(contracts, multiProvider, config);
        local = liquidityLayerApp.getContracts(localChain).liquidityLayerRouter;
    }));
    it('can transfer tokens via Circle', () => __awaiter(void 0, void 0, void 0, function* () {
        const recipientF = new core_1.TestLiquidityLayerMessageRecipient__factory(signer);
        const recipient = yield recipientF.deploy();
        const amount = 1000;
        yield mockToken.mint(signer.address, amount);
        yield mockToken.approve(local.address, amount);
        yield local.dispatchWithTokens(remoteDomain, utils_1.utils.addressToBytes32(recipient.address), mockToken.address, amount, LiquidityLayerRouterDeployer_1.BridgeAdapterType.Circle, '0x01');
        const transferNonce = yield circleTokenMessenger.nextNonce();
        const nonceId = yield messageTransmitter.hashSourceAndNonce(localDomain, transferNonce);
        yield messageTransmitter.process(nonceId, liquidityLayerApp.getContracts(remoteChain).circleBridgeAdapter.address, amount);
        yield coreApp.processMessages();
        (0, chai_1.expect)((yield mockToken.balanceOf(recipient.address)).toNumber()).to.eql(amount);
    }));
    it('can transfer tokens via Portal', () => __awaiter(void 0, void 0, void 0, function* () {
        const recipientF = new core_1.TestLiquidityLayerMessageRecipient__factory(signer);
        const recipient = yield recipientF.deploy();
        const amount = 1000;
        yield mockToken.mint(signer.address, amount);
        yield mockToken.approve(local.address, amount);
        yield local.dispatchWithTokens(remoteDomain, utils_1.utils.addressToBytes32(recipient.address), mockToken.address, amount, LiquidityLayerRouterDeployer_1.BridgeAdapterType.Portal, '0x01');
        const originAdapter = liquidityLayerApp.getContracts(localChain).portalAdapter;
        const destinationAdapter = liquidityLayerApp.getContracts(remoteChain).portalAdapter;
        yield destinationAdapter.completeTransfer(yield portalBridge.mockPortalVaa(localDomain, yield originAdapter.nonce(), amount));
        yield coreApp.processMessages();
        (0, chai_1.expect)((yield mockToken.balanceOf(recipient.address)).toNumber()).to.eql(amount);
    }));
}));
//# sourceMappingURL=liquidity-layer.hardhat-test.js.map