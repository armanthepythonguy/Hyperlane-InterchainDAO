"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiquidityLayerDeployer = exports.BridgeAdapterType = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const ProxiedRouterDeployer_1 = require("../../router/ProxiedRouterDeployer");
const objects_1 = require("../../utils/objects");
const contracts_1 = require("./contracts");
var BridgeAdapterType;
(function (BridgeAdapterType) {
    BridgeAdapterType["Circle"] = "Circle";
    BridgeAdapterType["Portal"] = "Portal";
})(BridgeAdapterType = exports.BridgeAdapterType || (exports.BridgeAdapterType = {}));
class LiquidityLayerDeployer extends ProxiedRouterDeployer_1.ProxiedRouterDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_1.liquidityLayerFactories);
        this.routerContractName = 'liquidityLayerRouter';
    }
    constructorArgs(_, __) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    initializeArgs(chain, config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const owner = yield this.multiProvider.getSignerAddress(chain);
            return [
                config.mailbox,
                config.interchainGasPaymaster,
                (_a = config.interchainSecurityModule) !== null && _a !== void 0 ? _a : ethers_1.ethers.constants.AddressZero,
                owner,
            ];
        });
    }
    enrollRemoteRouters(contractsMap, configMap, foreignRouters) {
        const _super = Object.create(null, {
            enrollRemoteRouters: { get: () => super.enrollRemoteRouters }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Enroll LiquidityLayerRouters with each other`);
            yield _super.enrollRemoteRouters.call(this, contractsMap, configMap, foreignRouters);
            this.logger(`Enroll CircleBridgeAdapters with each other`);
            // Hack to allow use of super.enrollRemoteRouters
            yield _super.enrollRemoteRouters.call(this, (0, objects_1.objMap)((0, objects_1.objFilter)(contractsMap, (_, c) => !!c.circleBridgeAdapter), (_, contracts) => ({
                liquidityLayerRouter: contracts.circleBridgeAdapter,
            })), configMap, foreignRouters);
            this.logger(`Enroll PortalAdapters with each other`);
            // Hack to allow use of super.enrollRemoteRouters
            yield _super.enrollRemoteRouters.call(this, (0, objects_1.objMap)((0, objects_1.objFilter)(contractsMap, (_, c) => !!c.portalAdapter), (_, contracts) => ({
                liquidityLayerRouter: contracts.portalAdapter,
            })), configMap, foreignRouters);
        });
    }
    // Custom contract deployment logic can go here
    // If no custom logic is needed, call deployContract for the router
    deployContracts(chain, config) {
        const _super = Object.create(null, {
            deployContracts: { get: () => super.deployContracts }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // This is just the temp owner for contracts, and HyperlaneRouterDeployer#transferOwnership actually sets the configured owner
            const deployer = yield this.multiProvider.getSignerAddress(chain);
            const routerContracts = yield _super.deployContracts.call(this, chain, config);
            const bridgeAdapters = {};
            if (config.circle) {
                bridgeAdapters.circleBridgeAdapter = yield this.deployCircleBridgeAdapter(chain, config.circle, deployer, routerContracts.liquidityLayerRouter);
            }
            if (config.portal) {
                bridgeAdapters.portalAdapter = yield this.deployPortalAdapter(chain, config.portal, deployer, routerContracts.liquidityLayerRouter);
            }
            return Object.assign(Object.assign({}, routerContracts), bridgeAdapters);
        });
    }
    deployPortalAdapter(chain, adapterConfig, owner, router) {
        return __awaiter(this, void 0, void 0, function* () {
            const portalAdapter = yield this.deployContract(chain, 'portalAdapter', [], [
                this.multiProvider.getDomainId(chain),
                owner,
                adapterConfig.portalBridgeAddress,
                router.address,
            ]);
            for (const { wormholeDomain, hyperlaneDomain, } of adapterConfig.wormholeDomainMapping) {
                const expectedCircleDomain = yield portalAdapter.hyperlaneDomainToWormholeDomain(hyperlaneDomain);
                if (expectedCircleDomain === wormholeDomain)
                    continue;
                this.logger(`Set wormhole domain ${wormholeDomain} for hyperlane domain ${hyperlaneDomain}`);
                yield this.runIfOwner(chain, portalAdapter, () => this.multiProvider.handleTx(chain, portalAdapter.addDomain(hyperlaneDomain, wormholeDomain)));
            }
            if (!utils_1.utils.eqAddress(yield router.liquidityLayerAdapters('Portal'), portalAdapter.address)) {
                this.logger('Set Portal as LiquidityLayerAdapter on Router');
                yield this.runIfOwner(chain, portalAdapter, () => this.multiProvider.handleTx(chain, router.setLiquidityLayerAdapter(adapterConfig.type, portalAdapter.address)));
            }
            return portalAdapter;
        });
    }
    deployCircleBridgeAdapter(chain, adapterConfig, owner, router) {
        return __awaiter(this, void 0, void 0, function* () {
            const circleBridgeAdapter = yield this.deployContract(chain, 'circleBridgeAdapter', [], [
                owner,
                adapterConfig.tokenMessengerAddress,
                adapterConfig.messageTransmitterAddress,
                router.address,
            ]);
            if (!utils_1.utils.eqAddress(yield circleBridgeAdapter.tokenSymbolToAddress('USDC'), adapterConfig.usdcAddress)) {
                this.logger(`Set USDC token contract`);
                yield this.runIfOwner(chain, circleBridgeAdapter, () => this.multiProvider.handleTx(chain, circleBridgeAdapter.addToken(adapterConfig.usdcAddress, 'USDC')));
            }
            // Set domain mappings
            for (const { circleDomain, hyperlaneDomain, } of adapterConfig.circleDomainMapping) {
                const expectedCircleDomain = yield circleBridgeAdapter.hyperlaneDomainToCircleDomain(hyperlaneDomain);
                if (expectedCircleDomain === circleDomain)
                    continue;
                this.logger(`Set circle domain ${circleDomain} for hyperlane domain ${hyperlaneDomain}`);
                yield this.runIfOwner(chain, circleBridgeAdapter, () => this.multiProvider.handleTx(chain, circleBridgeAdapter.addDomain(hyperlaneDomain, circleDomain)));
            }
            if (!utils_1.utils.eqAddress(yield router.liquidityLayerAdapters('Circle'), circleBridgeAdapter.address)) {
                this.logger('Set Circle as LiquidityLayerAdapter on Router');
                yield this.runIfOwner(chain, circleBridgeAdapter, () => this.multiProvider.handleTx(chain, router.setLiquidityLayerAdapter(adapterConfig.type, circleBridgeAdapter.address)));
            }
            return circleBridgeAdapter;
        });
    }
}
exports.LiquidityLayerDeployer = LiquidityLayerDeployer;
//# sourceMappingURL=LiquidityLayerRouterDeployer.js.map