"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const core_1 = require("@hyperlane-xyz/core");
const chains_1 = require("../../consts/chains");
const TestCoreDeployer_1 = require("../../core/TestCoreDeployer");
const MultiProvider_1 = require("../../providers/MultiProvider");
const testUtils_1 = require("../../test/testUtils");
const InterchainAccount_1 = require("./InterchainAccount");
const InterchainAccountChecker_1 = require("./InterchainAccountChecker");
const InterchainAccountDeployer_1 = require("./InterchainAccountDeployer");
describe('InterchainAccounts', () => __awaiter(void 0, void 0, void 0, function* () {
    const localChain = chains_1.Chains.test1;
    const remoteChain = chains_1.Chains.test2;
    let signer;
    let contracts;
    let local;
    let remote;
    let multiProvider;
    let coreApp;
    let config;
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        [signer] = yield hardhat_1.ethers.getSigners();
        multiProvider = MultiProvider_1.MultiProvider.createTestMultiProvider({ signer });
        coreApp = yield new TestCoreDeployer_1.TestCoreDeployer(multiProvider).deployApp();
        config = yield (0, testUtils_1.deployTestIgpsAndGetRouterConfig)(multiProvider, signer.address, coreApp.contractsMap);
    }));
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const deployer = new InterchainAccountDeployer_1.InterchainAccountDeployer(multiProvider);
        contracts = yield deployer.deploy(config);
        local = contracts[localChain].interchainAccountRouter;
        remote = contracts[remoteChain].interchainAccountRouter;
    }));
    it('checks', () => __awaiter(void 0, void 0, void 0, function* () {
        const app = new InterchainAccount_1.InterchainAccount(contracts, multiProvider);
        const checker = new InterchainAccountChecker_1.InterchainAccountChecker(multiProvider, app, config);
        yield checker.check();
        (0, chai_1.expect)(checker.violations.length).to.eql(0);
    }));
    it('forwards calls from interchain account', () => __awaiter(void 0, void 0, void 0, function* () {
        const recipientF = new core_1.TestRecipient__factory(signer);
        const recipient = yield recipientF.deploy();
        const fooMessage = 'Test';
        const data = recipient.interface.encodeFunctionData('fooBar', [
            1,
            fooMessage,
        ]);
        const icaAddress = yield remote['getLocalInterchainAccount(uint32,address,address,address)'](multiProvider.getDomainId(localChain), signer.address, local.address, hardhat_1.ethers.constants.AddressZero);
        yield local['callRemote(uint32,address,uint256,bytes)'](multiProvider.getDomainId(remoteChain), recipient.address, 0, data);
        yield coreApp.processMessages();
        (0, chai_1.expect)(yield recipient.lastCallMessage()).to.eql(fooMessage);
        (0, chai_1.expect)(yield recipient.lastCaller()).to.eql(icaAddress);
    }));
}));
//# sourceMappingURL=accounts.hardhat-test.js.map