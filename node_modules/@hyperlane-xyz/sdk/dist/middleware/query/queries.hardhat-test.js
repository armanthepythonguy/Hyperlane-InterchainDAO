"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../../consts/chainMetadata");
const chains_1 = require("../../consts/chains");
const TestCoreApp_1 = require("../../core/TestCoreApp");
const TestCoreDeployer_1 = require("../../core/TestCoreDeployer");
const MultiProvider_1 = require("../../providers/MultiProvider");
const testUtils_1 = require("../../test/testUtils");
const InterchainQuery_1 = require("./InterchainQuery");
const InterchainQueryChecker_1 = require("./InterchainQueryChecker");
const InterchainQueryDeployer_1 = require("./InterchainQueryDeployer");
describe('InterchainQueryRouter', () => __awaiter(void 0, void 0, void 0, function* () {
    const localChain = chains_1.Chains.test1;
    const remoteChain = chains_1.Chains.test2;
    const localDomain = chainMetadata_1.chainMetadata[localChain].chainId;
    const remoteDomain = chainMetadata_1.chainMetadata[remoteChain].chainId;
    let contracts;
    let signer;
    let local;
    let remote;
    let multiProvider;
    let coreApp;
    let config;
    let testQuery;
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        [signer] = yield hardhat_1.ethers.getSigners();
        multiProvider = MultiProvider_1.MultiProvider.createTestMultiProvider({ signer });
        const coreDeployer = new TestCoreDeployer_1.TestCoreDeployer(multiProvider);
        const coreContractsMaps = yield coreDeployer.deploy();
        coreApp = new TestCoreApp_1.TestCoreApp(coreContractsMaps, multiProvider);
        config = yield (0, testUtils_1.deployTestIgpsAndGetRouterConfig)(multiProvider, signer.address, coreContractsMaps);
    }));
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const InterchainQuery = new InterchainQueryDeployer_1.InterchainQueryDeployer(multiProvider);
        contracts = yield InterchainQuery.deploy(config);
        local = contracts[localChain].interchainQueryRouter;
        remote = contracts[remoteChain].interchainQueryRouter;
        testQuery = yield new core_1.TestQuery__factory(signer).deploy(local.address);
    }));
    it('checks', () => __awaiter(void 0, void 0, void 0, function* () {
        const app = new InterchainQuery_1.InterchainQuery(contracts, multiProvider);
        const checker = new InterchainQueryChecker_1.InterchainQueryChecker(multiProvider, app, config);
        yield checker.check();
        (0, chai_1.expect)(checker.violations.length).to.eql(0);
    }));
    it('completes query round trip and invokes callback', () => __awaiter(void 0, void 0, void 0, function* () {
        const secret = 123;
        const sender = testQuery.address;
        const bytes32sender = utils_1.utils.addressToBytes32(sender);
        const expectedOwner = yield remote.owner();
        yield (0, chai_1.expect)(testQuery.queryRouterOwner(remoteDomain, secret))
            .to.emit(local, 'QueryDispatched')
            .withArgs(remoteDomain, sender);
        const result = yield coreApp.processOutboundMessages(localChain);
        const response = result.get(remoteChain)[0];
        yield (0, chai_1.expect)(response)
            .to.emit(remote, 'QueryExecuted')
            .withArgs(localDomain, bytes32sender);
        const result2 = yield coreApp.processOutboundMessages(remoteChain);
        const response2 = result2.get(localChain)[0];
        yield (0, chai_1.expect)(response2)
            .to.emit(local, 'QueryResolved')
            .withArgs(remoteDomain, sender);
        yield (0, chai_1.expect)(response2)
            .to.emit(testQuery, 'Owner')
            .withArgs(secret, expectedOwner);
    }));
}));
//# sourceMappingURL=queries.hardhat-test.js.map