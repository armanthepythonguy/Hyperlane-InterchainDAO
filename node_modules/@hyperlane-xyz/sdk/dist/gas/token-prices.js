"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinGeckoTokenPriceGetter = void 0;
const coingecko_api_1 = __importDefault(require("coingecko-api"));
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../consts/chainMetadata");
const chains_1 = require("../consts/chains");
class TokenPriceCache {
    constructor(freshSeconds = 60, evictionSeconds = 3 * 60 * 60) {
        this.cache = new Map();
        this.freshSeconds = freshSeconds;
        this.evictionSeconds = evictionSeconds;
    }
    put(chain, price) {
        const now = new Date();
        this.cache.set(chain, { timestamp: now, price });
    }
    isFresh(chain) {
        const entry = this.cache.get(chain);
        if (!entry)
            return false;
        const expiryTime = new Date(entry.timestamp.getTime() + 1000 * this.freshSeconds);
        const now = new Date();
        return now < expiryTime;
    }
    fetch(chain) {
        const entry = this.cache.get(chain);
        if (!entry) {
            throw new Error(`no entry found for ${chain} in token price cache`);
        }
        const evictionTime = new Date(entry.timestamp.getTime() + 1000 * this.evictionSeconds);
        const now = new Date();
        if (now > evictionTime) {
            throw new Error(`evicted entry found for ${chain} in token price cache`);
        }
        return entry.price;
    }
}
class CoinGeckoTokenPriceGetter {
    constructor(coinGecko, expirySeconds, chainMetadata = chainMetadata_1.chainMetadata) {
        this.coinGecko = coinGecko;
        this.cache = new TokenPriceCache(expirySeconds);
        this.metadata = chainMetadata;
    }
    static withDefaultCoinGecko(expirySeconds) {
        const coinGecko = new coingecko_api_1.default();
        return new CoinGeckoTokenPriceGetter(coinGecko, expirySeconds);
    }
    getTokenPrice(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const [price] = yield this.getTokenPrices([chain]);
            return price;
        });
    }
    getTokenExchangeRate(base, quote) {
        return __awaiter(this, void 0, void 0, function* () {
            const [basePrice, quotePrice] = yield this.getTokenPrices([base, quote]);
            return basePrice / quotePrice;
        });
    }
    getTokenPrices(chains) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO improve PI support here?
            const isMainnet = chains.map((c) => chains_1.Mainnets.includes(c));
            const allMainnets = isMainnet.every((v) => v === true);
            const allTestnets = isMainnet.every((v) => v === false);
            if (allTestnets) {
                // Testnet tokens are all artificially priced at 1.0 USD.
                return chains.map(() => 1);
            }
            if (!allMainnets) {
                throw new Error('Cannot mix testnets and mainnets when fetching token prices');
            }
            const toQuery = chains.filter((c) => !this.cache.isFresh(c));
            if (toQuery.length > 0) {
                try {
                    yield this.queryTokenPrices(toQuery);
                }
                catch (e) {
                    (0, utils_1.warn)('Failed to query token prices', e);
                }
            }
            return chains.map((chain) => this.cache.fetch(chain));
        });
    }
    queryTokenPrices(chains) {
        return __awaiter(this, void 0, void 0, function* () {
            const currency = 'usd';
            // The CoinGecko API expects, in some cases, IDs that do not match
            // ChainNames.
            const ids = chains.map((chain) => this.metadata[chain].gasCurrencyCoinGeckoId || chain);
            const response = yield this.coinGecko.simple.price({
                ids,
                vs_currencies: [currency],
            });
            const prices = ids.map((id) => response.data[id][currency]);
            // Update the cache with the newly fetched prices
            chains.map((chain, i) => this.cache.put(chain, prices[i]));
        });
    }
}
exports.CoinGeckoTokenPriceGetter = CoinGeckoTokenPriceGetter;
//# sourceMappingURL=token-prices.js.map