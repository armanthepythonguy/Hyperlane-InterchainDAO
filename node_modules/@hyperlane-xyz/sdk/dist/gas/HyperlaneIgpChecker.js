"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneIgpChecker = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const bytecode_1 = require("../consts/bytecode");
const HyperlaneAppChecker_1 = require("../deploy/HyperlaneAppChecker");
const proxy_1 = require("../deploy/proxy");
const objects_1 = require("../utils/objects");
const types_1 = require("./types");
class HyperlaneIgpChecker extends HyperlaneAppChecker_1.HyperlaneAppChecker {
    checkChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkDomainOwnership(chain);
            yield this.checkProxiedContracts(chain);
            yield this.checkBytecodes(chain);
            yield this.checkOverheadInterchainGasPaymaster(chain);
            yield this.checkInterchainGasPaymaster(chain);
        });
    }
    checkDomainOwnership(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = this.configMap[chain];
            if (config.owner) {
                return this.checkOwnership(chain, config.owner);
            }
        });
    }
    checkBytecodes(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const contracts = this.app.getContracts(chain);
            yield this.checkBytecode(chain, 'InterchainGasPaymaster proxy', contracts.interchainGasPaymaster.address, [bytecode_1.BytecodeHash.TRANSPARENT_PROXY_BYTECODE_HASH]);
            const implementation = yield (0, proxy_1.proxyImplementation)(this.multiProvider.getProvider(chain), contracts.interchainGasPaymaster.address);
            yield this.checkBytecode(chain, 'InterchainGasPaymaster implementation', implementation, [
                bytecode_1.BytecodeHash.INTERCHAIN_GAS_PAYMASTER_BYTECODE_HASH,
                bytecode_1.BytecodeHash.OWNER_INITIALIZABLE_INTERCHAIN_GAS_PAYMASTER_BYTECODE_HASH,
            ]);
            yield this.checkBytecode(chain, 'OverheadIGP', contracts.defaultIsmInterchainGasPaymaster.address, [bytecode_1.BytecodeHash.OVERHEAD_IGP_BYTECODE_HASH], (bytecode) => 
            // Remove the address of the wrapped IGP from the bytecode
            bytecode.replaceAll(ethers_1.utils.defaultAbiCoder
                .encode(['address'], [contracts.interchainGasPaymaster.address])
                .slice(2), ''));
        });
    }
    checkOverheadInterchainGasPaymaster(local) {
        return __awaiter(this, void 0, void 0, function* () {
            const coreContracts = this.app.getContracts(local);
            const defaultIsmIgp = coreContracts.defaultIsmInterchainGasPaymaster;
            // Construct the violation, updating the actual & expected
            // objects as violations are found.
            // A single violation is used so that only a single `setDestinationGasOverheads`
            // call is generated to set multiple gas overheads.
            const overheadViolation = {
                type: 'InterchainGasPaymaster',
                subType: types_1.IgpViolationType.Overhead,
                contract: defaultIsmIgp,
                chain: local,
                actual: {},
                expected: {},
            };
            const remotes = this.app.remoteChains(local);
            for (const remote of remotes) {
                const expectedOverhead = this.configMap[local].overhead[remote];
                const remoteId = this.multiProvider.getDomainId(remote);
                const existingOverhead = yield defaultIsmIgp.destinationGasOverhead(remoteId);
                if (!existingOverhead.eq(expectedOverhead)) {
                    const remoteChain = remote;
                    overheadViolation.actual[remoteChain] = existingOverhead;
                    overheadViolation.expected[remoteChain] =
                        ethers_1.BigNumber.from(expectedOverhead);
                }
            }
            if (Object.keys(overheadViolation.actual).length > 0) {
                this.addViolation(overheadViolation);
            }
        });
    }
    checkInterchainGasPaymaster(local) {
        return __awaiter(this, void 0, void 0, function* () {
            const coreContracts = this.app.getContracts(local);
            const igp = coreContracts.interchainGasPaymaster;
            // Construct the violation, updating the actual & expected
            // objects as violations are found.
            // A single violation is used so that only a single `setGasOracles`
            // call is generated to set multiple gas oracles.
            const gasOraclesViolation = {
                type: 'InterchainGasPaymaster',
                subType: types_1.IgpViolationType.GasOracles,
                contract: igp,
                chain: local,
                actual: {},
                expected: {},
            };
            const remotes = this.app.remoteChains(local);
            for (const remote of remotes) {
                const remoteId = this.multiProvider.getDomainId(remote);
                const actualGasOracle = yield igp.gasOracles(remoteId);
                const expectedGasOracle = this.getGasOracleAddress(local, remote);
                if (!utils_1.utils.eqAddress(actualGasOracle, expectedGasOracle)) {
                    const remoteChain = remote;
                    gasOraclesViolation.actual[remoteChain] = actualGasOracle;
                    gasOraclesViolation.expected[remoteChain] = expectedGasOracle;
                }
            }
            // Add the violation only if it's been populated with gas oracle inconsistencies
            if (Object.keys(gasOraclesViolation.actual).length > 0) {
                this.addViolation(gasOraclesViolation);
            }
            const actualBeneficiary = yield igp.beneficiary();
            const expectedBeneficiary = this.configMap[local].beneficiary;
            if (!utils_1.utils.eqAddress(actualBeneficiary, expectedBeneficiary)) {
                const violation = {
                    type: 'InterchainGasPaymaster',
                    subType: types_1.IgpViolationType.Beneficiary,
                    contract: igp,
                    chain: local,
                    actual: actualBeneficiary,
                    expected: expectedBeneficiary,
                };
                this.addViolation(violation);
            }
        });
    }
    // The owner of storageGasOracle is not expected to match the configured owner
    ownables(chain) {
        const _super = Object.create(null, {
            ownables: { get: () => super.ownables }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return (0, objects_1.objFilter)(yield _super.ownables.call(this, chain), (name, contract) => name !== 'storageGasOracle');
        });
    }
    getGasOracleAddress(local, remote) {
        const config = this.configMap[local];
        const gasOracleType = config.gasOracleType[remote];
        if (!gasOracleType) {
            throw Error(`Expected gas oracle type for local ${local} and remote ${remote}`);
        }
        const coreContracts = this.app.getContracts(local);
        switch (gasOracleType) {
            case types_1.GasOracleContractType.StorageGasOracle:
                return coreContracts.storageGasOracle.address;
            default:
                throw Error(`Unsupported gas oracle type ${gasOracleType}`);
        }
    }
}
exports.HyperlaneIgpChecker = HyperlaneIgpChecker;
//# sourceMappingURL=HyperlaneIgpChecker.js.map