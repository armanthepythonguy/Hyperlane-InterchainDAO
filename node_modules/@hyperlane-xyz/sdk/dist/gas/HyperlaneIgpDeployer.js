"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneIgpDeployer = void 0;
const debug_1 = __importDefault(require("debug"));
const utils_1 = require("@hyperlane-xyz/utils");
const contracts_1 = require("../contracts");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const objects_1 = require("../utils/objects");
const contracts_2 = require("./contracts");
class HyperlaneIgpDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_2.igpFactories, {
            logger: (0, debug_1.default)('hyperlane:IgpDeployer'),
        });
    }
    deployInterchainGasPaymaster(chain, proxyAdmin, storageGasOracle, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = config.owner;
            const beneficiary = config.beneficiary;
            const igp = yield this.deployProxiedContract(chain, 'interchainGasPaymaster', proxyAdmin.address, [], [owner, beneficiary]);
            const gasOracleConfigsToSet = [];
            const remotes = Object.keys(config.gasOracleType);
            for (const remote of remotes) {
                const remoteId = this.multiProvider.getDomainId(remote);
                const currentGasOracle = yield igp.gasOracles(remoteId);
                if (!utils_1.utils.eqAddress(currentGasOracle, storageGasOracle.address)) {
                    gasOracleConfigsToSet.push({
                        remoteDomain: remoteId,
                        gasOracle: storageGasOracle.address,
                    });
                }
            }
            if (gasOracleConfigsToSet.length > 0) {
                yield this.runIfOwner(chain, igp, () => __awaiter(this, void 0, void 0, function* () {
                    return this.multiProvider.handleTx(chain, igp.setGasOracles(gasOracleConfigsToSet));
                }));
            }
            return igp;
        });
    }
    deployOverheadIgp(chain, interchainGasPaymasterAddress, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const overheadInterchainGasPaymaster = yield this.deployContract(chain, 'defaultIsmInterchainGasPaymaster', [interchainGasPaymasterAddress]);
            // Only set gas overhead configs if they differ from what's on chain
            const configs = [];
            const remotes = Object.keys(config.overhead);
            for (const remote of remotes) {
                const remoteDomain = this.multiProvider.getDomainId(remote);
                const gasOverhead = config.overhead[remote];
                const existingOverhead = yield overheadInterchainGasPaymaster.destinationGasOverhead(remoteDomain);
                if (!existingOverhead.eq(gasOverhead)) {
                    configs.push({ domain: remoteDomain, gasOverhead });
                }
            }
            if (configs.length > 0) {
                yield this.runIfOwner(chain, overheadInterchainGasPaymaster, () => this.multiProvider.handleTx(chain, overheadInterchainGasPaymaster.setDestinationGasOverheads(configs, this.multiProvider.getTransactionOverrides(chain))));
            }
            return overheadInterchainGasPaymaster;
        });
    }
    deployStorageGasOracle(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.deployContract(chain, 'storageGasOracle', []);
        });
    }
    deployContracts(chain, config) {
        return __awaiter(this, void 0, void 0, function* () {
            // NB: To share ProxyAdmins with HyperlaneCore, ensure the ProxyAdmin
            // is loaded into the contract cache.
            const proxyAdmin = yield this.deployContract(chain, 'proxyAdmin', []);
            const storageGasOracle = yield this.deployStorageGasOracle(chain);
            const interchainGasPaymaster = yield this.deployInterchainGasPaymaster(chain, proxyAdmin, storageGasOracle, config);
            const overheadIgp = yield this.deployOverheadIgp(chain, interchainGasPaymaster.address, config);
            const contracts = {
                proxyAdmin,
                storageGasOracle,
                interchainGasPaymaster,
                defaultIsmInterchainGasPaymaster: overheadIgp,
            };
            // Do not transfer ownership of StorageGasOracle, as it should be
            // owned by a "hot" key so that prices can be updated regularly
            const ownables = yield (0, contracts_1.filterOwnableContracts)(contracts);
            const filteredOwnables = (0, objects_1.pick)(ownables, Object.keys(contracts).filter((name) => name !== 'storageGasOracle'));
            yield this.transferOwnershipOfContracts(chain, config.owner, filteredOwnables);
            return contracts;
        });
    }
}
exports.HyperlaneIgpDeployer = HyperlaneIgpDeployer;
//# sourceMappingURL=HyperlaneIgpDeployer.js.map