"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("@nomiclabs/hardhat-ethers");
require("@nomiclabs/hardhat-waffle");
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const chains_1 = require("../consts/chains");
const MultiProvider_1 = require("../providers/MultiProvider");
const TestCoreDeployer_1 = require("./TestCoreDeployer");
const localChain = chains_1.Chains.test1;
const remoteChain = chains_1.Chains.test2;
const message = '0xdeadbeef';
describe('TestCoreDeployer', () => __awaiter(void 0, void 0, void 0, function* () {
    let testCoreApp, localMailbox, remoteMailbox, dispatchReceipt;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const [signer] = yield hardhat_1.ethers.getSigners();
        const multiProvider = MultiProvider_1.MultiProvider.createTestMultiProvider({ signer });
        const deployer = new TestCoreDeployer_1.TestCoreDeployer(multiProvider);
        testCoreApp = yield deployer.deployApp();
        const recipient = yield new core_1.TestRecipient__factory(signer).deploy();
        localMailbox = testCoreApp.getContracts(localChain).mailbox;
        const dispatchResponse = localMailbox.dispatch(multiProvider.getDomainId(remoteChain), utils_1.utils.addressToBytes32(recipient.address), message);
        yield (0, chai_1.expect)(dispatchResponse).to.emit(localMailbox, 'Dispatch');
        dispatchReceipt = yield testCoreApp.multiProvider.handleTx(localChain, dispatchResponse);
        remoteMailbox = testCoreApp.getContracts(remoteChain).mailbox;
        yield (0, chai_1.expect)(remoteMailbox.dispatch(multiProvider.getDomainId(localChain), utils_1.utils.addressToBytes32(recipient.address), message)).to.emit(remoteMailbox, 'Dispatch');
    }));
    it('processes outbound messages for a single domain', () => __awaiter(void 0, void 0, void 0, function* () {
        const responses = yield testCoreApp.processOutboundMessages(localChain);
        (0, chai_1.expect)(responses.get(remoteChain).length).to.equal(1);
    }));
    it('processes outbound messages for two domains', () => __awaiter(void 0, void 0, void 0, function* () {
        const localResponses = yield testCoreApp.processOutboundMessages(localChain);
        (0, chai_1.expect)(localResponses.get(remoteChain).length).to.equal(1);
        const remoteResponses = yield testCoreApp.processOutboundMessages(remoteChain);
        (0, chai_1.expect)(remoteResponses.get(localChain).length).to.equal(1);
    }));
    it('processes all messages', () => __awaiter(void 0, void 0, void 0, function* () {
        const responses = yield testCoreApp.processMessages();
        (0, chai_1.expect)(responses.get(localChain).get(remoteChain).length).to.equal(1);
        (0, chai_1.expect)(responses.get(remoteChain).get(localChain).length).to.equal(1);
    }));
    it('waits on message processing receipts', () => __awaiter(void 0, void 0, void 0, function* () {
        const [receipts] = yield Promise.all([
            testCoreApp.waitForMessageProcessing(dispatchReceipt),
            testCoreApp.processOutboundMessages(localChain),
        ]);
        (0, chai_1.expect)(receipts).to.have.length(1);
    }));
}));
//# sourceMappingURL=testHyperlaneDeploy.hardhat-test.js.map