"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCore = void 0;
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneApp_1 = require("../HyperlaneApp");
const environments_1 = require("../consts/environments");
const contracts_1 = require("../contracts");
const contracts_2 = require("./contracts");
class HyperlaneCore extends HyperlaneApp_1.HyperlaneApp {
    static fromEnvironment(env, multiProvider) {
        const envAddresses = environments_1.hyperlaneEnvironments[env];
        if (!envAddresses) {
            throw new Error(`No addresses found for ${env}`);
        }
        return HyperlaneCore.fromAddressesMap(envAddresses, multiProvider);
    }
    static fromAddressesMap(addressesMap, multiProvider) {
        const helper = (0, contracts_1.appFromAddressesMapHelper)(addressesMap, contracts_2.coreFactories, multiProvider);
        return new HyperlaneCore(helper.contractsMap, helper.multiProvider);
    }
    getDestination(message) {
        const destinationChain = this.multiProvider.getChainName(message.parsed.destination);
        const mailbox = this.getContracts(destinationChain).mailbox;
        return { destinationChain, mailbox };
    }
    waitForProcessReceipt(message) {
        const id = utils_1.utils.messageId(message.message);
        const { destinationChain, mailbox } = this.getDestination(message);
        const filter = mailbox.filters.ProcessId(id);
        return new Promise((resolve, reject) => {
            mailbox.once(filter, (emittedId, event) => {
                if (id !== emittedId) {
                    reject(`Expected message id ${id} but got ${emittedId}`);
                }
                resolve(this.multiProvider.handleTx(destinationChain, event.getTransaction()));
            });
        });
    }
    waitForMessageWasProcessed(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = utils_1.utils.messageId(message.message);
            const { mailbox } = this.getDestination(message);
            yield utils_1.utils.pollAsync(() => __awaiter(this, void 0, void 0, function* () {
                const delivered = yield mailbox.delivered(id);
                if (!delivered) {
                    throw new Error(`Message ${id} not yet processed`);
                }
            }));
            return;
        });
    }
    waitForMessageProcessing(sourceTx) {
        const messages = HyperlaneCore.getDispatchedMessages(sourceTx);
        return Promise.all(messages.map((msg) => this.waitForProcessReceipt(msg)));
    }
    waitForMessageProcessed(sourceTx) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = HyperlaneCore.getDispatchedMessages(sourceTx);
            yield Promise.all(messages.map((msg) => this.waitForMessageWasProcessed(msg)));
        });
    }
    // Redundant with static method but keeping for backwards compatibility
    getDispatchedMessages(sourceTx) {
        return HyperlaneCore.getDispatchedMessages(sourceTx);
    }
    static getDispatchedMessages(sourceTx) {
        const mailbox = core_1.Mailbox__factory.createInterface();
        const dispatchLogs = sourceTx.logs
            .map((log) => {
            try {
                return mailbox.parseLog(log);
            }
            catch (e) {
                return undefined;
            }
        })
            .filter((log) => !!log && log.name === 'Dispatch');
        return dispatchLogs.map((log) => {
            const message = log.args['message'];
            const parsed = utils_1.utils.parseMessage(message);
            const id = utils_1.utils.messageId(message);
            return { id, message, parsed };
        });
    }
}
exports.HyperlaneCore = HyperlaneCore;
//# sourceMappingURL=HyperlaneCore.js.map