"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCoreChecker = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const bytecode_1 = require("../consts/bytecode");
const HyperlaneAppChecker_1 = require("../deploy/HyperlaneAppChecker");
const proxy_1 = require("../deploy/proxy");
const HyperlaneIsmFactory_1 = require("../ism/HyperlaneIsmFactory");
const types_1 = require("./types");
class HyperlaneCoreChecker extends HyperlaneAppChecker_1.HyperlaneAppChecker {
    constructor(multiProvider, app, configMap, ismFactory) {
        super(multiProvider, app, configMap);
        this.ismFactory = ismFactory;
    }
    checkChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = this.configMap[chain];
            // skip chains that are configured to be removed
            if (config.remove) {
                return;
            }
            yield this.checkDomainOwnership(chain);
            yield this.checkProxiedContracts(chain);
            yield this.checkMailbox(chain);
            yield this.checkBytecodes(chain);
            yield this.checkValidatorAnnounce(chain);
        });
    }
    checkDomainOwnership(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = this.configMap[chain];
            if (config.owner) {
                return this.checkOwnership(chain, config.owner);
            }
        });
    }
    checkMailbox(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const contracts = this.app.getContracts(chain);
            const mailbox = contracts.mailbox;
            const localDomain = yield mailbox.localDomain();
            utils_1.utils.assert(localDomain === this.multiProvider.getDomainId(chain));
            const actualIsm = yield mailbox.defaultIsm();
            const config = this.configMap[chain];
            /*
            TODO: Add this back in once the new ISM factories are adopted
            const matches = await moduleMatches(
              chain,
              actualIsm,
              config.defaultIsm,
              this.ismFactory.multiProvider,
              this.ismFactory.getContracts(chain),
            );
            */
            const matches = true;
            if (!matches) {
                const violation = {
                    type: types_1.CoreViolationType.Mailbox,
                    mailboxType: types_1.MailboxViolationType.DefaultIsm,
                    contract: mailbox,
                    chain,
                    actual: actualIsm,
                    expected: config.defaultIsm,
                };
                this.addViolation(violation);
            }
        });
    }
    checkBytecodes(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const contracts = this.app.getContracts(chain);
            const mailbox = contracts.mailbox;
            const localDomain = yield mailbox.localDomain();
            const implementation = yield (0, proxy_1.proxyImplementation)(this.multiProvider.getProvider(chain), mailbox.address);
            yield this.checkBytecode(chain, 'Mailbox implementation', implementation, [
                bytecode_1.BytecodeHash.MAILBOX_WITHOUT_LOCAL_DOMAIN_BYTE_CODE_HASH,
                bytecode_1.BytecodeHash.MAILBOX_WITHOUT_LOCAL_DOMAIN_NONZERO_PAUSE_BYTE_CODE_HASH,
            ], (bytecode) => 
            // This is obviously super janky but basically we are searching
            //  for the ocurrences of localDomain in the bytecode and remove
            //  that to compare, but some coincidental ocurrences of
            // localDomain in the bytecode should be not be removed which
            // are just done via an offset guard
            bytecode.replaceAll(ethers_1.utils.defaultAbiCoder
                .encode(['uint32'], [localDomain])
                .slice(2), (match, offset) => (offset > 8000 ? match : '')));
            yield this.checkBytecode(chain, 'Mailbox proxy', contracts.mailbox.address, [bytecode_1.BytecodeHash.TRANSPARENT_PROXY_BYTECODE_HASH]);
            yield this.checkBytecode(chain, 'ProxyAdmin', contracts.proxyAdmin.address, [bytecode_1.BytecodeHash.PROXY_ADMIN_BYTECODE_HASH]);
        });
    }
    checkValidatorAnnounce(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const validators = new Set();
            const remotes = Object.keys(this.configMap).filter((c) => c !== chain);
            const remoteOriginValidators = remotes.map((remote) => (0, HyperlaneIsmFactory_1.collectValidators)(chain, this.configMap[remote].defaultIsm));
            remoteOriginValidators.map((set) => {
                [...set].map((v) => validators.add(v));
            });
            const validatorAnnounce = this.app.getContracts(chain).validatorAnnounce;
            const announcedValidators = yield validatorAnnounce.getAnnouncedValidators();
            [...validators].forEach((validator) => {
                const matches = announcedValidators.filter((x) => utils_1.utils.eqAddress(x, validator));
                if (matches.length == 0) {
                    const violation = {
                        type: types_1.CoreViolationType.ValidatorAnnounce,
                        chain,
                        validator,
                        actual: false,
                        expected: true,
                    };
                    this.addViolation(violation);
                }
            });
        });
    }
}
exports.HyperlaneCoreChecker = HyperlaneCoreChecker;
//# sourceMappingURL=HyperlaneCoreChecker.js.map