import { ethers } from 'ethers';
import { Mailbox } from '@hyperlane-xyz/core';
import { types } from '@hyperlane-xyz/utils';
import { HyperlaneApp } from '../HyperlaneApp';
import { HyperlaneEnvironment } from '../consts/environments';
import { HyperlaneAddressesMap } from '../contracts';
import { MultiProvider } from '../providers/MultiProvider';
import { ChainName } from '../types';
import { CoreFactories } from './contracts';
export declare type DispatchedMessage = {
    id: string;
    message: string;
    parsed: types.ParsedMessage;
};
export declare class HyperlaneCore extends HyperlaneApp<CoreFactories> {
    static fromEnvironment<Env extends HyperlaneEnvironment>(env: Env, multiProvider: MultiProvider): HyperlaneCore;
    static fromAddressesMap(addressesMap: HyperlaneAddressesMap<any>, multiProvider: MultiProvider): HyperlaneCore;
    protected getDestination(message: DispatchedMessage): {
        destinationChain: ChainName;
        mailbox: Mailbox;
    };
    protected waitForProcessReceipt(message: DispatchedMessage): Promise<ethers.ContractReceipt>;
    protected waitForMessageWasProcessed(message: DispatchedMessage): Promise<void>;
    waitForMessageProcessing(sourceTx: ethers.ContractReceipt): Promise<ethers.ContractReceipt[]>;
    waitForMessageProcessed(sourceTx: ethers.ContractReceipt): Promise<void>;
    getDispatchedMessages(sourceTx: ethers.ContractReceipt): DispatchedMessage[];
    static getDispatchedMessages(sourceTx: ethers.ContractReceipt): DispatchedMessage[];
}
//# sourceMappingURL=HyperlaneCore.d.ts.map