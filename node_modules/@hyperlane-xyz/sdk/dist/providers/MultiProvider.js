"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiProvider = exports.defaultProviderBuilder = void 0;
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../consts/chainMetadata");
const chains_1 = require("../consts/chains");
const objects_1 = require("../utils/objects");
const RetryProvider_1 = require("./RetryProvider");
const DEFAULT_RETRY_OPTIONS = {
    maxRequests: 3,
    baseRetryMs: 250,
};
function defaultProviderBuilder(rpcUrls, network, retryOverride) {
    const createProvider = (r) => {
        const retry = r.retry || retryOverride;
        return retry
            ? new RetryProvider_1.RetryJsonRpcProvider(retry, r.http, network)
            : new ethers_1.providers.StaticJsonRpcProvider(r.http, network);
    };
    if (rpcUrls.length > 1) {
        return new ethers_1.providers.FallbackProvider(rpcUrls.map(createProvider), 1);
    }
    else if (rpcUrls.length === 1) {
        return createProvider(rpcUrls[0]);
    }
    else {
        throw new Error('No RPC URLs provided');
    }
}
exports.defaultProviderBuilder = defaultProviderBuilder;
class MultiProvider {
    /**
     * Create a new MultiProvider with the given chainMetadata,
     * or the SDK's default metadata if not provided
     */
    constructor(chainMetadata = chainMetadata_1.chainMetadata, options = {}) {
        this.metadata = {};
        this.providers = {};
        this.signers = {};
        this.useSharedSigner = false; // A single signer to be used for all chains
        Object.entries(chainMetadata).forEach(([key, cm]) => {
            if (key !== cm.name)
                throw new Error(`Chain name mismatch: Key was ${key}, but name is ${cm.name}`);
            this.addChain(cm);
        });
        this.logger = (0, debug_1.debug)((options === null || options === void 0 ? void 0 : options.loggerName) || 'hyperlane:MultiProvider');
        this.providerBuilder = (options === null || options === void 0 ? void 0 : options.providerBuilder) || defaultProviderBuilder;
    }
    /**
     * Add a chain to the MultiProvider
     * @throws if chain's name or domain/chain ID collide
     */
    addChain(metadata) {
        if (!(0, chainMetadata_1.isValidChainMetadata)(metadata))
            throw new Error(`Invalid chain metadata for ${metadata.name}`);
        // Ensure no two chains have overlapping names/domainIds/chainIds
        for (const chainMetadata of Object.values(this.metadata)) {
            const { name, chainId, domainId } = chainMetadata;
            if (name == metadata.name)
                throw new Error(`Duplicate chain name: ${name}`);
            // Chain and Domain Ids should be globally unique
            const idCollision = chainId == metadata.chainId ||
                domainId == metadata.chainId ||
                (metadata.domainId &&
                    (chainId == metadata.domainId || domainId === metadata.domainId));
            if (idCollision)
                throw new Error(`Chain/Domain id collision: ${name} and ${metadata.name}`);
        }
        this.metadata[metadata.name] = metadata;
        if (this.useSharedSigner) {
            const signers = Object.values(this.signers);
            if (signers.length > 0) {
                this.setSharedSigner(signers[0]);
            }
        }
    }
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    tryGetChainMetadata(chainNameOrId) {
        let chainMetadata;
        if (typeof chainNameOrId === 'string') {
            chainMetadata = this.metadata[chainNameOrId];
        }
        else if (typeof chainNameOrId === 'number') {
            chainMetadata = Object.values(this.metadata).find((m) => m.chainId === chainNameOrId || m.domainId === chainNameOrId);
        }
        return chainMetadata || null;
    }
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainMetadata(chainNameOrId) {
        const chainMetadata = this.tryGetChainMetadata(chainNameOrId);
        if (!chainMetadata)
            throw new Error(`No chain metadata set for ${chainNameOrId}`);
        return chainMetadata;
    }
    /**
     * Get the name for a given chain name, chain id, or domain id
     */
    tryGetChainName(chainNameOrId) {
        var _a, _b;
        return (_b = (_a = this.tryGetChainMetadata(chainNameOrId)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Get the name for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainName(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId).name;
    }
    /**
     * Get the names for all chains known to this MultiProvider
     */
    getKnownChainNames() {
        return Object.keys(this.metadata);
    }
    /**
     * Get the id for a given chain name, chain id, or domain id
     */
    tryGetChainId(chainNameOrId) {
        var _a, _b;
        return (_b = (_a = this.tryGetChainMetadata(chainNameOrId)) === null || _a === void 0 ? void 0 : _a.chainId) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Get the id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainId(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId).chainId;
    }
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownChainIds() {
        return Object.values(this.metadata).map((c) => c.chainId);
    }
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     */
    tryGetDomainId(chainNameOrId) {
        var _a, _b;
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        return (_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.domainId) !== null && _a !== void 0 ? _a : metadata === null || metadata === void 0 ? void 0 : metadata.chainId) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getDomainId(chainNameOrId) {
        var _a;
        const metadata = this.getChainMetadata(chainNameOrId);
        return (_a = metadata.domainId) !== null && _a !== void 0 ? _a : metadata.chainId;
    }
    /**
     * Get the domain ids for a list of chain names, chain ids, or domain ids
     * @throws if any chain's metadata has not been set
     */
    getDomainIds(chainNamesOrIds) {
        return chainNamesOrIds.map((c) => this.getDomainId(c));
    }
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownDomainIds() {
        return this.getKnownChainNames().map(this.getDomainId);
    }
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     */
    tryGetProvider(chainNameOrId) {
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        if (!metadata)
            return null;
        const { name, chainId, publicRpcUrls } = metadata;
        if (this.providers[name])
            return this.providers[name];
        if (chains_1.TestChains.includes(name)) {
            this.providers[name] = new ethers_1.providers.JsonRpcProvider('http://localhost:8545', 31337);
        }
        else if (publicRpcUrls.length) {
            this.providers[name] = this.providerBuilder(publicRpcUrls, chainId, DEFAULT_RETRY_OPTIONS);
        }
        else {
            return null;
        }
        return this.providers[name];
    }
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getProvider(chainNameOrId) {
        const provider = this.tryGetProvider(chainNameOrId);
        if (!provider)
            throw new Error(`No chain metadata set for ${chainNameOrId}`);
        return provider;
    }
    /**
     * Sets an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    setProvider(chainNameOrId, provider) {
        const chainName = this.getChainName(chainNameOrId);
        this.providers[chainName] = provider;
        const signer = this.signers[chainName];
        if (signer && signer.provider) {
            this.setSigner(chainName, signer.connect(provider));
        }
        return provider;
    }
    /**
     * Sets Ethers providers for a set of chains
     * @throws if chain's metadata has not been set
     */
    setProviders(providers) {
        for (const chain of Object.keys(providers)) {
            const chainName = this.getChainName(chain);
            this.providers[chainName] = providers[chain];
        }
    }
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     */
    tryGetSigner(chainNameOrId) {
        const chainName = this.tryGetChainName(chainNameOrId);
        if (!chainName)
            return null;
        const signer = this.signers[chainName];
        if (!signer)
            return null;
        if (signer.provider)
            return signer;
        // Auto-connect the signer for convenience
        const provider = this.tryGetProvider(chainName);
        return provider ? signer.connect(provider) : signer;
    }
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     * @throws if chain's metadata or signer has not been set
     */
    getSigner(chainNameOrId) {
        const signer = this.tryGetSigner(chainNameOrId);
        if (!signer)
            throw new Error(`No chain signer set for ${chainNameOrId}`);
        return signer;
    }
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata or signer has not been set
     */
    getSignerAddress(chainNameOrId) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.getSigner(chainNameOrId);
            const address = yield signer.getAddress();
            return address;
        });
    }
    /**
     * Sets an Ethers Signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigner(chainNameOrId, signer) {
        if (this.useSharedSigner) {
            throw new Error('MultiProvider already set to use a shared signer');
        }
        const chainName = this.getChainName(chainNameOrId);
        this.signers[chainName] = signer;
        if (signer.provider && !this.providers[chainName]) {
            this.providers[chainName] = signer.provider;
        }
        return signer;
    }
    /**
     * Sets Ethers Signers for a set of chains
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigners(signers) {
        if (this.useSharedSigner) {
            throw new Error('MultiProvider already set to use a shared signer');
        }
        for (const chain of Object.keys(signers)) {
            const chainName = this.getChainName(chain);
            this.signers[chainName] = signers[chain];
        }
    }
    /**
     * Gets the Signer if it's been set, otherwise the provider
     */
    tryGetSignerOrProvider(chainNameOrId) {
        return (this.tryGetSigner(chainNameOrId) || this.tryGetProvider(chainNameOrId));
    }
    /**
     * Gets the Signer if it's been set, otherwise the provider
     * @throws if chain metadata has not been set
     */
    getSignerOrProvider(chainNameOrId) {
        return this.tryGetSigner(chainNameOrId) || this.getProvider(chainNameOrId);
    }
    /**
     * Sets Ethers Signers to be used for all chains
     * Any subsequent calls to getSigner will return given signer
     * Setting sharedSigner to null clears all signers
     */
    setSharedSigner(sharedSigner) {
        if (!sharedSigner) {
            this.useSharedSigner = false;
            this.signers = {};
            return null;
        }
        this.useSharedSigner = true;
        for (const chain of this.getKnownChainNames()) {
            this.signers[chain] = sharedSigner;
        }
        return sharedSigner;
    }
    /**
     * Create a new MultiProvider from the intersection
     * of current's chains and the provided chain list
     */
    intersect(chains, throwIfNotSubset = false) {
        const ownChains = this.getKnownChainNames();
        const intersection = [];
        for (const chain of chains) {
            if (ownChains.includes(chain)) {
                intersection.push(chain);
            }
            else if (throwIfNotSubset) {
                throw new Error(`MultiProvider#intersect: chains specified ${chain}, but ownChains did not include it`);
            }
        }
        if (!intersection.length) {
            throw new Error(`No chains shared between MultiProvider and list (${ownChains} and ${chains})`);
        }
        const intersectionMetadata = (0, objects_1.pick)(this.metadata, intersection);
        const intersectionProviders = (0, objects_1.pick)(this.providers, intersection);
        const intersectionSigners = (0, objects_1.pick)(this.signers, intersection);
        const multiProvider = new MultiProvider(intersectionMetadata);
        multiProvider.setProviders(intersectionProviders);
        multiProvider.setSigners(intersectionSigners);
        return { intersection, multiProvider };
    }
    /**
     * Get chain names excluding given chain name
     */
    getRemoteChains(name) {
        return utils_1.utils.exclude(name, this.getKnownChainNames());
    }
    /**
     * Get an RPC URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getRpcUrl(chainNameOrId) {
        const { publicRpcUrls } = this.getChainMetadata(chainNameOrId);
        if (!(publicRpcUrls === null || publicRpcUrls === void 0 ? void 0 : publicRpcUrls.length) || !publicRpcUrls[0].http)
            throw new Error(`No RPC URl configured for ${chainNameOrId}`);
        return publicRpcUrls[0].http;
    }
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerUrl(chainNameOrId) {
        var _a;
        const explorers = (_a = this.tryGetChainMetadata(chainNameOrId)) === null || _a === void 0 ? void 0 : _a.blockExplorers;
        if (!(explorers === null || explorers === void 0 ? void 0 : explorers.length))
            return null;
        return explorers[0].url;
    }
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerUrl(chainNameOrId) {
        const url = this.tryGetExplorerUrl(chainNameOrId);
        if (!url)
            throw new Error(`No explorer url set for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer's API URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerApiUrl(chainNameOrId) {
        var _a;
        const explorers = (_a = this.tryGetChainMetadata(chainNameOrId)) === null || _a === void 0 ? void 0 : _a.blockExplorers;
        if (!(explorers === null || explorers === void 0 ? void 0 : explorers.length) || !explorers[0].apiUrl)
            return null;
        const { apiUrl, apiKey } = explorers[0];
        if (!apiKey)
            return apiUrl;
        const url = new URL(apiUrl);
        url.searchParams.set('apikey', apiKey);
        return url.toString();
    }
    /**
     * Get a block explorer API URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerApiUrl(chainNameOrId) {
        const url = this.tryGetExplorerApiUrl(chainNameOrId);
        if (!url)
            throw new Error(`No explorer api url set for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer URL for given chain's tx
     */
    tryGetExplorerTxUrl(chainNameOrId, response) {
        const baseUrl = this.tryGetExplorerUrl(chainNameOrId);
        return baseUrl ? `${baseUrl}/tx/${response.hash}` : null;
    }
    /**
     * Get a block explorer URL for given chain's tx
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerTxUrl(chainNameOrId, response) {
        return `${this.getExplorerUrl(chainNameOrId)}/tx/${response.hash}`;
    }
    /**
     * Get a block explorer URL for given chain's address
     */
    tryGetExplorerAddressUrl(chainNameOrId, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseUrl = this.tryGetExplorerUrl(chainNameOrId);
            if (!baseUrl)
                return null;
            if (address)
                return `${baseUrl}/address/${address}`;
            const signer = this.tryGetSigner(chainNameOrId);
            if (!signer)
                return null;
            return `${baseUrl}/address/${yield signer.getAddress()}`;
        });
    }
    /**
     * Get a block explorer URL for given chain's address
     * @throws if chain's metadata, signer, or block explorer data has no been set
     */
    getExplorerAddressUrl(chainNameOrId, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this.tryGetExplorerAddressUrl(chainNameOrId, address);
            if (!url)
                throw new Error(`Missing data for address url for ${chainNameOrId}`);
            return url;
        });
    }
    /**
     * Get the transaction overrides for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getTransactionOverrides(chainNameOrId) {
        var _a, _b;
        return (_b = (_a = this.getChainMetadata(chainNameOrId)) === null || _a === void 0 ? void 0 : _a.transactionOverrides) !== null && _b !== void 0 ? _b : {};
    }
    /**
     * Wait for given tx to be confirmed
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    handleTx(chainNameOrId, tx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const confirmations = ((_a = this.getChainMetadata(chainNameOrId).blocks) === null || _a === void 0 ? void 0 : _a.confirmations) || 1;
            const response = yield tx;
            const txUrl = this.tryGetExplorerTxUrl(chainNameOrId, response);
            this.logger(`Pending ${txUrl || response.hash} (waiting ${confirmations} blocks for confirmation)`);
            return response.wait(confirmations);
        });
    }
    /**
     * Populate a transaction's fields using signer address and overrides
     * @throws if chain's metadata has not been set or tx fails
     */
    prepareTx(chainNameOrId, tx, from) {
        return __awaiter(this, void 0, void 0, function* () {
            const txFrom = from ? from : yield this.getSignerAddress(chainNameOrId);
            const overrides = this.getTransactionOverrides(chainNameOrId);
            return Object.assign(Object.assign(Object.assign({}, tx), { from: txFrom }), overrides);
        });
    }
    /**
     * Estimate gas for given tx
     * @throws if chain's metadata has not been set or tx fails
     */
    estimateGas(chainNameOrId, tx, from) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReq = Object.assign(Object.assign({}, (yield this.prepareTx(chainNameOrId, tx, from))), { 
                // Reset any tx request params that may have an unintended effect on gas estimation
                gasLimit: undefined, gasPrice: undefined, maxPriorityFeePerGas: undefined, maxFeePerGas: undefined });
            const provider = this.getProvider(chainNameOrId);
            return provider.estimateGas(txReq);
        });
    }
    /**
     * Send a transaction and wait for confirmation
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    sendTransaction(chainNameOrId, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReq = yield this.prepareTx(chainNameOrId, tx);
            const signer = this.getSigner(chainNameOrId);
            const response = yield signer.sendTransaction(txReq);
            this.logger(`Sent tx ${response.hash}`);
            return this.handleTx(chainNameOrId, response);
        });
    }
    /**
     * Run given function on all known chains
     */
    mapKnownChains(fn) {
        const result = {};
        for (const chain of this.getKnownChainNames()) {
            result[chain] = fn(chain);
        }
        return result;
    }
    /**
     * Creates a MultiProvider using the given signer for all test networks
     */
    static createTestMultiProvider(params = {}, chains = chains_1.TestChains) {
        const { signer, provider } = params;
        const chainMetadata = (0, objects_1.pick)(chainMetadata_1.chainMetadata, chains);
        const mp = new MultiProvider(chainMetadata);
        if (signer) {
            mp.setSharedSigner(signer);
        }
        const _provider = provider || (signer === null || signer === void 0 ? void 0 : signer.provider);
        if (_provider) {
            const providerMap = {};
            chains.forEach((t) => (providerMap[t] = _provider));
            mp.setProviders(providerMap);
        }
        return mp;
    }
}
exports.MultiProvider = MultiProvider;
//# sourceMappingURL=MultiProvider.js.map