import { Debugger } from 'debug';
import { BigNumber, ContractReceipt, ContractTransaction, PopulatedTransaction, Signer, providers } from 'ethers';
import { types } from '@hyperlane-xyz/utils';
import { ChainMetadata } from '../consts/chainMetadata';
import { ChainMap, ChainName } from '../types';
import { RetryProviderOptions } from './RetryProvider';
declare type Provider = providers.Provider;
export declare function defaultProviderBuilder(rpcUrls: ChainMetadata['publicRpcUrls'], network: providers.Networkish, retryOverride?: RetryProviderOptions): Provider;
export declare type ProviderBuilderFn = typeof defaultProviderBuilder;
interface MultiProviderOptions {
    loggerName?: string;
    providerBuilder?: ProviderBuilderFn;
}
export declare class MultiProvider {
    readonly metadata: ChainMap<ChainMetadata>;
    protected readonly providers: ChainMap<Provider>;
    protected readonly providerBuilder: ProviderBuilderFn;
    protected signers: ChainMap<Signer>;
    protected useSharedSigner: boolean;
    protected readonly logger: Debugger;
    /**
     * Create a new MultiProvider with the given chainMetadata,
     * or the SDK's default metadata if not provided
     */
    constructor(chainMetadata?: ChainMap<ChainMetadata>, options?: MultiProviderOptions);
    /**
     * Add a chain to the MultiProvider
     * @throws if chain's name or domain/chain ID collide
     */
    addChain(metadata: ChainMetadata): void;
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    tryGetChainMetadata(chainNameOrId: ChainName | number): ChainMetadata | null;
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainMetadata(chainNameOrId: ChainName | number): ChainMetadata;
    /**
     * Get the name for a given chain name, chain id, or domain id
     */
    tryGetChainName(chainNameOrId: ChainName | number): string | null;
    /**
     * Get the name for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainName(chainNameOrId: ChainName | number): string;
    /**
     * Get the names for all chains known to this MultiProvider
     */
    getKnownChainNames(): string[];
    /**
     * Get the id for a given chain name, chain id, or domain id
     */
    tryGetChainId(chainNameOrId: ChainName | number): number | null;
    /**
     * Get the id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainId(chainNameOrId: ChainName | number): number;
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownChainIds(): number[];
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     */
    tryGetDomainId(chainNameOrId: ChainName | number): number | null;
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getDomainId(chainNameOrId: ChainName | number): number;
    /**
     * Get the domain ids for a list of chain names, chain ids, or domain ids
     * @throws if any chain's metadata has not been set
     */
    getDomainIds(chainNamesOrIds: Array<ChainName | number>): number[];
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownDomainIds(): number[];
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     */
    tryGetProvider(chainNameOrId: ChainName | number): Provider | null;
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getProvider(chainNameOrId: ChainName | number): Provider;
    /**
     * Sets an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    setProvider(chainNameOrId: ChainName | number, provider: Provider): Provider;
    /**
     * Sets Ethers providers for a set of chains
     * @throws if chain's metadata has not been set
     */
    setProviders(providers: ChainMap<Provider>): void;
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     */
    tryGetSigner(chainNameOrId: ChainName | number): Signer | null;
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     * @throws if chain's metadata or signer has not been set
     */
    getSigner(chainNameOrId: ChainName | number): Signer;
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata or signer has not been set
     */
    getSignerAddress(chainNameOrId: ChainName | number): Promise<types.Address>;
    /**
     * Sets an Ethers Signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigner(chainNameOrId: ChainName | number, signer: Signer): Signer;
    /**
     * Sets Ethers Signers for a set of chains
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigners(signers: ChainMap<Signer>): void;
    /**
     * Gets the Signer if it's been set, otherwise the provider
     */
    tryGetSignerOrProvider(chainNameOrId: ChainName | number): Signer | Provider | null;
    /**
     * Gets the Signer if it's been set, otherwise the provider
     * @throws if chain metadata has not been set
     */
    getSignerOrProvider(chainNameOrId: ChainName | number): Signer | Provider;
    /**
     * Sets Ethers Signers to be used for all chains
     * Any subsequent calls to getSigner will return given signer
     * Setting sharedSigner to null clears all signers
     */
    setSharedSigner(sharedSigner: Signer | null): Signer | null;
    /**
     * Create a new MultiProvider from the intersection
     * of current's chains and the provided chain list
     */
    intersect(chains: ChainName[], throwIfNotSubset?: boolean): {
        intersection: ChainName[];
        multiProvider: MultiProvider;
    };
    /**
     * Get chain names excluding given chain name
     */
    getRemoteChains(name: ChainName): ChainName[];
    /**
     * Get an RPC URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getRpcUrl(chainNameOrId: ChainName | number): string;
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerUrl(chainNameOrId: ChainName | number): string | null;
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerUrl(chainNameOrId: ChainName | number): string;
    /**
     * Get a block explorer's API URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerApiUrl(chainNameOrId: ChainName | number): string | null;
    /**
     * Get a block explorer API URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerApiUrl(chainNameOrId: ChainName | number): string;
    /**
     * Get a block explorer URL for given chain's tx
     */
    tryGetExplorerTxUrl(chainNameOrId: ChainName | number, response: {
        hash: string;
    }): string | null;
    /**
     * Get a block explorer URL for given chain's tx
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerTxUrl(chainNameOrId: ChainName | number, response: {
        hash: string;
    }): string;
    /**
     * Get a block explorer URL for given chain's address
     */
    tryGetExplorerAddressUrl(chainNameOrId: ChainName | number, address?: string): Promise<string | null>;
    /**
     * Get a block explorer URL for given chain's address
     * @throws if chain's metadata, signer, or block explorer data has no been set
     */
    getExplorerAddressUrl(chainNameOrId: ChainName | number, address?: string): Promise<string>;
    /**
     * Get the transaction overrides for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getTransactionOverrides(chainNameOrId: ChainName | number): Partial<providers.TransactionRequest>;
    /**
     * Wait for given tx to be confirmed
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    handleTx(chainNameOrId: ChainName | number, tx: ContractTransaction | Promise<ContractTransaction>): Promise<ContractReceipt>;
    /**
     * Populate a transaction's fields using signer address and overrides
     * @throws if chain's metadata has not been set or tx fails
     */
    prepareTx(chainNameOrId: ChainName | number, tx: PopulatedTransaction, from?: string): Promise<providers.TransactionRequest>;
    /**
     * Estimate gas for given tx
     * @throws if chain's metadata has not been set or tx fails
     */
    estimateGas(chainNameOrId: ChainName | number, tx: PopulatedTransaction, from?: string): Promise<BigNumber>;
    /**
     * Send a transaction and wait for confirmation
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    sendTransaction(chainNameOrId: ChainName | number, tx: PopulatedTransaction): Promise<ContractReceipt>;
    /**
     * Run given function on all known chains
     */
    mapKnownChains<Output>(fn: (n: ChainName) => Output): ChainMap<Output>;
    /**
     * Creates a MultiProvider using the given signer for all test networks
     */
    static createTestMultiProvider(params?: {
        signer?: Signer;
        provider?: Provider;
    }, chains?: ChainName[]): MultiProvider;
}
export {};
//# sourceMappingURL=MultiProvider.d.ts.map