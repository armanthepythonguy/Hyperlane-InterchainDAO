"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractVerifier = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const utils_1 = require("@hyperlane-xyz/utils");
const utils_2 = require("@hyperlane-xyz/utils/dist/src/utils");
const MultiGeneric_1 = require("../../utils/MultiGeneric");
var ExplorerApiActions;
(function (ExplorerApiActions) {
    ExplorerApiActions["GETSOURCECODE"] = "getsourcecode";
    ExplorerApiActions["VERIFY_IMPLEMENTATION"] = "verifysourcecode";
    ExplorerApiActions["MARK_PROXY"] = "verifyproxycontract";
    ExplorerApiActions["CHECK_STATUS"] = "checkverifystatus";
    ExplorerApiActions["CHECK_PROXY_STATUS"] = "checkproxyverification";
})(ExplorerApiActions || (ExplorerApiActions = {}));
var ExplorerApiErrors;
(function (ExplorerApiErrors) {
    ExplorerApiErrors["ALREADY_VERIFIED"] = "Contract source code already verified";
    ExplorerApiErrors["ALREADY_VERIFIED_ALT"] = "Already Verified";
    ExplorerApiErrors["VERIFICATION_PENDING"] = "Pending in queue";
    ExplorerApiErrors["PROXY_FAILED"] = "A corresponding implementation contract was unfortunately not detected for the proxy address.";
})(ExplorerApiErrors || (ExplorerApiErrors = {}));
class ContractVerifier extends MultiGeneric_1.MultiGeneric {
    constructor(verificationInputs, multiProvider, apiKeys, flattenedSource, // flattened source code from eg `hardhat flatten`
    compilerOptions) {
        super(verificationInputs);
        this.multiProvider = multiProvider;
        this.apiKeys = apiKeys;
        this.flattenedSource = flattenedSource;
        this.compilerOptions = compilerOptions;
        this.logger = (0, debug_1.debug)('hyperlane:ContractVerifier');
    }
    verify(targets = this.chains()) {
        return Promise.allSettled(targets.map((chain) => this.verifyChain(chain, this.get(chain))));
    }
    verifyChain(chain, inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Verifying ${chain}...`);
            for (const input of inputs) {
                yield this.verifyContract(chain, input);
            }
        });
    }
    submitForm(chain, action, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const apiUrl = new URL(this.multiProvider.getExplorerApiUrl(chain));
            const isGetRequest = action === ExplorerApiActions.CHECK_STATUS ||
                action === ExplorerApiActions.CHECK_PROXY_STATUS ||
                action === ExplorerApiActions.GETSOURCECODE;
            const params = new URLSearchParams(Object.assign({ apikey: this.apiKeys[chain], module: 'contract', action }, options));
            let response;
            if (isGetRequest) {
                response = yield (0, cross_fetch_1.default)(`${apiUrl}?${params}`);
            }
            else {
                response = yield (0, cross_fetch_1.default)(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: params,
                });
            }
            let result;
            let responseText;
            try {
                responseText = yield response.text();
                result = JSON.parse(responseText);
            }
            catch (e) {
                this.logger(`Failed to parse response from ${responseText}`, e);
            }
            if (result.message === 'NOTOK') {
                switch (result.result) {
                    case ExplorerApiErrors.VERIFICATION_PENDING:
                        yield utils_1.utils.sleep(5000); // wait 5 seconds
                        return this.submitForm(chain, action, options);
                    case ExplorerApiErrors.ALREADY_VERIFIED:
                    case ExplorerApiErrors.ALREADY_VERIFIED_ALT:
                        return;
                    case ExplorerApiErrors.PROXY_FAILED:
                        this.logger(`Proxy verification failed, try manually?`);
                        return;
                    default:
                        this.logger(`Verification failed for some unknown reason on ${chain}`, result);
                        throw new Error(`Verification failed: ${result.result}`);
                }
            }
            return result.result;
        });
    }
    isAlreadyVerified(chain, input) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.submitForm(chain, ExplorerApiActions.GETSOURCECODE, Object.assign(Object.assign({}, this.compilerOptions), { address: input.address }));
                return result[0].SourceCode !== '';
            }
            catch (error) {
                this.logger(`Error checking if contract is already verified: ${error}`);
                return false;
            }
        });
    }
    verifyProxy(chain, input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (input.isProxy) {
                try {
                    const proxyGuid = yield this.submitForm(chain, ExplorerApiActions.MARK_PROXY, {
                        address: input.address,
                    });
                    const addressUrl = yield this.multiProvider.tryGetExplorerAddressUrl(chain, input.address);
                    // poll for verified proxy status
                    if (proxyGuid) {
                        yield this.submitForm(chain, ExplorerApiActions.CHECK_PROXY_STATUS, {
                            guid: proxyGuid,
                        });
                        this.logger(`Successfully verified proxy ${addressUrl}#readProxyContract`);
                    }
                }
                catch (error) {
                    console.error(`Verification of proxy at ${input.address} failed on ${chain}`);
                    throw error;
                }
            }
        });
    }
    verifyImplementation(chain, input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Verifying ${input.name} implementation at ${input.address} on ${chain}`);
            const data = Object.assign({ sourceCode: this.flattenedSource, contractname: input.name, contractaddress: input.address, 
                // TYPO IS ENFORCED BY API
                constructorArguements: utils_1.utils.strip0x((_a = input.constructorArguments) !== null && _a !== void 0 ? _a : '') }, this.compilerOptions);
            const guid = yield this.submitForm(chain, ExplorerApiActions.VERIFY_IMPLEMENTATION, data);
            const addressUrl = yield this.multiProvider.tryGetExplorerAddressUrl(chain, input.address);
            // poll for verified status
            if (guid) {
                try {
                    yield this.submitForm(chain, ExplorerApiActions.CHECK_STATUS, { guid });
                    this.logger(`Successfully verified ${addressUrl}#code`);
                }
                catch (error) {
                    console.error(`Verifying implementation at ${input.address} failed on ${chain}`);
                    throw error;
                }
            }
        });
    }
    verifyContract(chain, input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (input.address === ethers_1.ethers.constants.AddressZero) {
                return;
            }
            if (Array.isArray(input.constructorArguments)) {
                this.logger('Constructor arguments in legacy format, skipping');
                return;
            }
            if (yield this.isAlreadyVerified(chain, input)) {
                this.logger(`Contract ${input.name} already verified on ${chain}`);
                // There is a rate limit of 5 requests per second
                yield (0, utils_2.sleep)(200);
                return;
            }
            else {
                yield this.verifyImplementation(chain, input);
            }
            yield this.verifyProxy(chain, input);
        });
    }
}
exports.ContractVerifier = ContractVerifier;
//# sourceMappingURL=ContractVerifier.js.map