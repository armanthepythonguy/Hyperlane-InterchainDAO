"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneAppChecker = void 0;
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("@hyperlane-xyz/utils");
const contracts_1 = require("../contracts");
const objects_1 = require("../utils/objects");
const proxy_1 = require("./proxy");
const types_1 = require("./types");
class HyperlaneAppChecker {
    constructor(multiProvider, app, configMap) {
        this.multiProvider = multiProvider;
        this.app = app;
        this.violations = [];
        this.configMap = configMap;
    }
    check() {
        return __awaiter(this, void 0, void 0, function* () {
            Object.keys(this.configMap)
                .filter((_) => !this.app.chains().includes(_))
                .forEach((chain) => this.addViolation({
                type: types_1.ViolationType.NotDeployed,
                chain,
                expected: '',
                actual: '',
            }));
            return Promise.all(this.app.chains().map((chain) => this.checkChain(chain)));
        });
    }
    addViolation(violation) {
        this.violations.push(violation);
    }
    checkProxiedContracts(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const expectedAdmin = this.app.getContracts(chain).proxyAdmin.address;
            if (!expectedAdmin) {
                throw new Error(`Checking proxied contracts for ${chain} with no admin provided`);
            }
            const provider = this.multiProvider.getProvider(chain);
            const contracts = this.app.getContracts(chain);
            yield (0, objects_1.promiseObjAll)((0, objects_1.objMap)(contracts, (name, contract) => __awaiter(this, void 0, void 0, function* () {
                if (yield (0, proxy_1.isProxy)(provider, contract.address)) {
                    // Check the ProxiedContract's admin matches expectation
                    const actualAdmin = yield (0, proxy_1.proxyAdmin)(provider, contract.address);
                    if (!utils_2.utils.eqAddress(actualAdmin, expectedAdmin)) {
                        this.addViolation({
                            type: types_1.ViolationType.ProxyAdmin,
                            chain,
                            name,
                            expected: expectedAdmin,
                            actual: actualAdmin,
                        });
                    }
                }
            })));
        });
    }
    removeBytecodeMetadata(bytecode) {
        // https://docs.soliditylang.org/en/v0.8.17/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode
        // Remove solc metadata from bytecode
        return bytecode.substring(0, bytecode.length - 90);
    }
    // This method checks whether the bytecode of a contract matches the expected bytecode. It forces the deployer to explicitly acknowledge a change in bytecode. The violations can be remediated by updating the expected bytecode hash.
    checkBytecode(chain, name, address, expectedBytecodeHashes, modifyBytecodePriorToHash = (_) => _) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.multiProvider.getProvider(chain);
            const bytecode = yield provider.getCode(address);
            const bytecodeHash = (0, utils_1.keccak256)(modifyBytecodePriorToHash(this.removeBytecodeMetadata(bytecode)));
            if (!expectedBytecodeHashes.includes(bytecodeHash)) {
                this.addViolation({
                    type: types_1.ViolationType.BytecodeMismatch,
                    chain,
                    expected: expectedBytecodeHashes,
                    actual: bytecodeHash,
                    name,
                });
            }
        });
    }
    ownables(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const contracts = this.app.getContracts(chain);
            return (0, contracts_1.filterOwnableContracts)(contracts);
        });
    }
    // TODO: Require owner in config if ownables is non-empty
    checkOwnership(chain, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownableContracts = yield this.ownables(chain);
            for (const [name, contract] of Object.entries(ownableContracts)) {
                const actual = yield contract.owner();
                if (!utils_2.utils.eqAddress(actual, owner)) {
                    const violation = {
                        chain,
                        name,
                        type: types_1.ViolationType.Owner,
                        actual,
                        expected: owner,
                        contract,
                    };
                    this.addViolation(violation);
                }
            }
        });
    }
    expectViolations(violationCounts) {
        // Every type should have exactly the number of expected matches.
        (0, objects_1.objMap)(violationCounts, (type, count) => {
            const actual = this.violations.filter((v) => v.type === type).length;
            utils_2.utils.assert(actual == count, `Expected ${count} ${type} violations, got ${actual}`);
        });
        this.violations
            .filter((v) => !(v.type in violationCounts))
            .map((v) => {
            utils_2.utils.assert(false, `Unexpected violation: ${JSON.stringify(v)}`);
        });
    }
    expectEmpty() {
        const count = this.violations.length;
        utils_2.utils.assert(count === 0, `Found ${count} violations`);
    }
}
exports.HyperlaneAppChecker = HyperlaneAppChecker;
//# sourceMappingURL=HyperlaneAppChecker.js.map