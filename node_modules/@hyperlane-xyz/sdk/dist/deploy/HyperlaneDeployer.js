"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneDeployer = void 0;
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const proxy_1 = require("./proxy");
const utils_2 = require("./verify/utils");
class HyperlaneDeployer {
    constructor(multiProvider, factories, options) {
        var _a, _b;
        this.multiProvider = multiProvider;
        this.factories = factories;
        this.options = options;
        this.verificationInputs = {};
        this.cachedAddresses = {};
        this.deployedContracts = {};
        this.startingBlockNumbers = {};
        this.logger = (_a = options === null || options === void 0 ? void 0 : options.logger) !== null && _a !== void 0 ? _a : (0, debug_1.debug)('hyperlane:deployer');
        this.chainTimeoutMs = (_b = options === null || options === void 0 ? void 0 : options.chainTimeoutMs) !== null && _b !== void 0 ? _b : 5 * 60 * 1000; // 5 minute timeout per chain
    }
    cacheAddressesMap(addressesMap) {
        this.cachedAddresses = addressesMap;
    }
    checkConfig(_) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    deploy(configMap) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkConfig(configMap);
            const configChains = Object.keys(configMap);
            const targetChains = this.multiProvider.intersect(configChains, true).intersection;
            this.logger(`Start deploy to ${targetChains}`);
            for (const chain of targetChains) {
                const signerUrl = yield this.multiProvider.tryGetExplorerAddressUrl(chain);
                const signerAddress = yield this.multiProvider.getSignerAddress(chain);
                const fromString = signerUrl || signerAddress;
                this.logger(`Deploying to ${chain} from ${fromString}`);
                this.startingBlockNumbers[chain] = yield this.multiProvider
                    .getProvider(chain)
                    .getBlockNumber();
                yield utils_1.utils.runWithTimeout(this.chainTimeoutMs, () => __awaiter(this, void 0, void 0, function* () {
                    this.deployedContracts[chain] = yield this.deployContracts(chain, configMap[chain]);
                }));
            }
            return this.deployedContracts;
        });
    }
    runIf(chain, address, fn, label = 'address') {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = yield this.multiProvider.getSignerAddress(chain);
            if (utils_1.utils.eqAddress(address, signer)) {
                return fn();
            }
            else {
                this.logger(`Signer (${signer}) does not match ${label} (${address})`);
            }
            return undefined;
        });
    }
    runIfOwner(chain, ownable, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.runIf(chain, yield ownable.callStatic.owner(), fn, 'owner');
        });
    }
    runIfAdmin(chain, proxy, signerAdminFn, proxyAdminOwnerFn) {
        return __awaiter(this, void 0, void 0, function* () {
            const admin = yield (0, proxy_1.proxyAdmin)(this.multiProvider.getProvider(chain), proxy.address);
            const code = yield this.multiProvider.getProvider(chain).getCode(admin);
            // if admin is a ProxyAdmin, run the proxyAdminOwnerFn (if deployer is owner)
            if (code !== '0x') {
                this.logger(`Admin is a ProxyAdmin (${admin})`);
                const proxyAdmin = core_1.ProxyAdmin__factory.connect(admin, proxy.signer);
                return this.runIfOwner(chain, proxyAdmin, () => proxyAdminOwnerFn(proxyAdmin));
            }
            else {
                this.logger(`Admin is an EOA (${admin})`);
                // if admin is an EOA, run the signerAdminFn (if deployer is admin)
                return this.runIf(chain, admin, () => signerAdminFn(), 'admin');
            }
        });
    }
    initConnectionClient(local, connectionClient, config) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Initializing connection client (if not already) on ${local}...`);
            yield this.runIfOwner(local, connectionClient, () => __awaiter(this, void 0, void 0, function* () {
                // set mailbox if not already set (and configured)
                if (config.mailbox !== (yield connectionClient.mailbox())) {
                    this.logger(`Set mailbox on (${local})`);
                    yield this.multiProvider.handleTx(local, connectionClient.setMailbox(config.mailbox));
                }
                // set interchain gas paymaster if not already set (and configured)
                if (config.interchainGasPaymaster !==
                    (yield connectionClient.interchainGasPaymaster())) {
                    this.logger(`Set interchain gas paymaster on ${local}`);
                    yield this.multiProvider.handleTx(local, connectionClient.setInterchainGasPaymaster(config.interchainGasPaymaster));
                }
                // set interchain security module if not already set (and configured)
                if (config.interchainSecurityModule &&
                    config.interchainSecurityModule !==
                        (yield connectionClient.interchainSecurityModule())) {
                    this.logger(`Set interchain security module on ${local}`);
                    yield this.multiProvider.handleTx(local, connectionClient.setInterchainSecurityModule(config.interchainSecurityModule));
                }
            }));
            this.logger(`Connection client on ${local} initialized...`);
        });
    }
    deployContractFromFactory(chain, factory, contractName, constructorArgs, initializeArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedContract = this.readCache(chain, factory, contractName);
            if (cachedContract) {
                return cachedContract;
            }
            const signer = this.multiProvider.getSigner(chain);
            const overrides = this.multiProvider.getTransactionOverrides(chain);
            this.logger(`Deploy ${contractName} on ${chain}`);
            const contract = yield factory
                .connect(signer)
                .deploy(...constructorArgs, overrides);
            yield this.multiProvider.handleTx(chain, contract.deployTransaction);
            if (initializeArgs) {
                this.logger(`Initialize ${contractName} on ${chain}`);
                const initTx = yield contract.initialize(...initializeArgs);
                yield this.multiProvider.handleTx(chain, initTx);
            }
            const verificationInput = (0, utils_2.getContractVerificationInput)(contractName, contract, factory.bytecode);
            this.verificationInputs[chain] = this.verificationInputs[chain] || [];
            this.verificationInputs[chain].push(verificationInput);
            return contract;
        });
    }
    deployContract(chain, contractName, constructorArgs, initializeArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = (yield this.deployContractFromFactory(chain, this.factories[contractName], contractName.toString(), constructorArgs, initializeArgs));
            this.writeCache(chain, contractName, contract.address);
            return contract;
        });
    }
    changeAdmin(chain, proxy, admin) {
        return __awaiter(this, void 0, void 0, function* () {
            const actualAdmin = yield (0, proxy_1.proxyAdmin)(this.multiProvider.getProvider(chain), proxy.address);
            if (utils_1.utils.eqAddress(admin, actualAdmin)) {
                this.logger(`Admin set correctly, skipping admin change`);
                return;
            }
            this.logger(`Changing proxy admin`);
            yield this.runIfAdmin(chain, proxy, () => this.multiProvider.handleTx(chain, proxy.changeAdmin(admin)), (proxyAdmin) => this.multiProvider.handleTx(chain, proxyAdmin.changeProxyAdmin(proxy.address, admin)));
        });
    }
    upgradeAndInitialize(chain, proxy, implementation, initializeArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const current = yield proxy.callStatic.implementation();
            if (utils_1.utils.eqAddress(implementation.address, current)) {
                this.logger(`Implementation set correctly, skipping upgrade`);
                return;
            }
            this.logger(`Upgrading and initializing implementation`);
            const initData = implementation.interface.encodeFunctionData('initialize', initializeArgs);
            const overrides = this.multiProvider.getTransactionOverrides(chain);
            yield this.runIfAdmin(chain, proxy, () => this.multiProvider.handleTx(chain, proxy.upgradeToAndCall(implementation.address, initData, overrides)), (proxyAdmin) => this.multiProvider.handleTx(chain, proxyAdmin.upgradeAndCall(proxy.address, implementation.address, initData, overrides)));
        });
    }
    deployProxy(chain, implementation, proxyAdmin, initializeArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const initData = initializeArgs
                ? implementation.interface.encodeFunctionData('initialize', initializeArgs)
                : '0x';
            this.logger(`Deploying transparent upgradable proxy`);
            const constructorArgs = [
                implementation.address,
                proxyAdmin,
                initData,
            ];
            const proxy = yield this.deployContractFromFactory(chain, new core_1.TransparentUpgradeableProxy__factory(), 'TransparentUpgradeableProxy', constructorArgs);
            return implementation.attach(proxy.address);
        });
    }
    writeCache(chain, contractName, address) {
        if (!this.cachedAddresses[chain]) {
            this.cachedAddresses[chain] = {};
        }
        this.cachedAddresses[chain][contractName] = address;
    }
    readCache(chain, factory, contractName) {
        var _a;
        const cachedAddress = (_a = this.cachedAddresses[chain]) === null || _a === void 0 ? void 0 : _a[contractName];
        const hit = !!cachedAddress;
        const contractAddress = hit ? cachedAddress : ethers_1.ethers.constants.AddressZero;
        const contract = factory
            .attach(contractAddress)
            .connect(this.multiProvider.getSignerOrProvider(chain));
        if (hit) {
            this.logger(`Recovered ${contractName.toString()} on ${chain} ${cachedAddress}`);
            return contract;
        }
        return undefined;
    }
    /**
     * Deploys the Implementation and Proxy for a given contract
     *
     */
    deployProxiedContract(chain, contractName, proxyAdmin, constructorArgs, initializeArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedContract = this.readCache(chain, this.factories[contractName], contractName.toString());
            if (cachedContract) {
                return cachedContract;
            }
            // Try to initialize the implementation even though it may not be necessary
            const implementation = yield this.deployContract(chain, contractName, constructorArgs, initializeArgs);
            // Initialize the proxy the same way
            const contract = yield this.deployProxy(chain, implementation, proxyAdmin, initializeArgs);
            this.writeCache(chain, contractName, contract.address);
            return contract;
        });
    }
    mergeWithExistingVerificationInputs(existingInputsMap) {
        const allChains = new Set();
        Object.keys(existingInputsMap).forEach((_) => allChains.add(_));
        Object.keys(this.verificationInputs).forEach((_) => allChains.add(_));
        const ret = {};
        for (const chain of allChains) {
            const existingInputs = existingInputsMap[chain] || [];
            const newInputs = this.verificationInputs[chain] || [];
            ret[chain] = [...existingInputs, ...newInputs];
        }
        return ret;
    }
    transferOwnershipOfContracts(chain, owner, ownables) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipts = [];
            for (const contractName of Object.keys(ownables)) {
                const ownable = ownables[contractName];
                const currentOwner = yield ownable.owner();
                if (!utils_1.utils.eqAddress(currentOwner, owner)) {
                    this.logger(`Transferring ownership of ${contractName} to ${owner} on ${chain}`);
                    const receipt = yield this.runIfOwner(chain, ownable, () => this.multiProvider.handleTx(chain, ownable.transferOwnership(owner, this.multiProvider.getTransactionOverrides(chain))));
                    if (receipt)
                        receipts.push(receipt);
                }
            }
            return receipts.filter((x) => !!x);
        });
    }
}
exports.HyperlaneDeployer = HyperlaneDeployer;
//# sourceMappingURL=HyperlaneDeployer.js.map