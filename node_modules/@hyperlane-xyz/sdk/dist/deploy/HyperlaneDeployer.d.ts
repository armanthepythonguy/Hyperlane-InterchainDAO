import { Debugger } from 'debug';
import { Contract, ethers } from 'ethers';
import { HyperlaneConnectionClient, Ownable, ProxyAdmin, TransparentUpgradeableProxy } from '@hyperlane-xyz/core';
import { types } from '@hyperlane-xyz/utils';
import { HyperlaneAddressesMap, HyperlaneContracts, HyperlaneContractsMap, HyperlaneFactories } from '../contracts';
import { MultiProvider } from '../providers/MultiProvider';
import { ConnectionClientConfig } from '../router/types';
import { ChainMap, ChainName } from '../types';
import { ContractVerificationInput } from './verify/types';
export interface DeployerOptions {
    logger?: Debugger;
    chainTimeoutMs?: number;
}
export declare abstract class HyperlaneDeployer<Config, Factories extends HyperlaneFactories> {
    protected readonly multiProvider: MultiProvider;
    protected readonly factories: Factories;
    protected readonly options?: DeployerOptions | undefined;
    verificationInputs: ChainMap<ContractVerificationInput[]>;
    cachedAddresses: HyperlaneAddressesMap<any>;
    deployedContracts: HyperlaneContractsMap<Factories>;
    startingBlockNumbers: ChainMap<number | undefined>;
    protected logger: Debugger;
    protected chainTimeoutMs: number;
    constructor(multiProvider: MultiProvider, factories: Factories, options?: DeployerOptions | undefined);
    cacheAddressesMap(addressesMap: HyperlaneAddressesMap<any>): void;
    checkConfig(_: ChainMap<Config>): Promise<void>;
    abstract deployContracts(chain: ChainName, config: Config): Promise<HyperlaneContracts<Factories>>;
    deploy(configMap: ChainMap<Config>): Promise<HyperlaneContractsMap<Factories>>;
    protected runIf<T>(chain: ChainName, address: string, fn: () => Promise<T>, label?: string): Promise<T | undefined>;
    protected runIfOwner<T>(chain: ChainName, ownable: Ownable, fn: () => Promise<T>): Promise<T | undefined>;
    protected runIfAdmin<T>(chain: ChainName, proxy: Contract, signerAdminFn: () => Promise<T>, proxyAdminOwnerFn: (proxyAdmin: ProxyAdmin) => Promise<T>): Promise<T | undefined>;
    protected initConnectionClient(local: ChainName, connectionClient: HyperlaneConnectionClient, config: ConnectionClientConfig): Promise<void>;
    protected deployContractFromFactory<F extends ethers.ContractFactory>(chain: ChainName, factory: F, contractName: string, constructorArgs: Parameters<F['deploy']>, initializeArgs?: Parameters<Awaited<ReturnType<F['deploy']>>['initialize']>): Promise<ReturnType<F['deploy']>>;
    deployContract<K extends keyof Factories>(chain: ChainName, contractName: K, constructorArgs: Parameters<Factories[K]['deploy']>, initializeArgs?: Parameters<Awaited<ReturnType<Factories[K]['deploy']>>['initialize']>): Promise<HyperlaneContracts<Factories>[K]>;
    protected changeAdmin(chain: ChainName, proxy: TransparentUpgradeableProxy, admin: string): Promise<void>;
    protected upgradeAndInitialize<C extends ethers.Contract>(chain: ChainName, proxy: TransparentUpgradeableProxy, implementation: C, initializeArgs: Parameters<C['initialize']>): Promise<void>;
    protected deployProxy<C extends ethers.Contract>(chain: ChainName, implementation: C, proxyAdmin: string, initializeArgs?: Parameters<C['initialize']>): Promise<C>;
    protected writeCache<K extends keyof Factories>(chain: ChainName, contractName: K, address: types.Address): void;
    protected readCache<F extends ethers.ContractFactory>(chain: ChainName, factory: F, contractName: string): Awaited<ReturnType<F['deploy']>> | undefined;
    /**
     * Deploys the Implementation and Proxy for a given contract
     *
     */
    deployProxiedContract<K extends keyof Factories>(chain: ChainName, contractName: K, proxyAdmin: string, constructorArgs: Parameters<Factories[K]['deploy']>, initializeArgs?: Parameters<HyperlaneContracts<Factories>[K]['initialize']>): Promise<HyperlaneContracts<Factories>[K]>;
    mergeWithExistingVerificationInputs(existingInputsMap: ChainMap<ContractVerificationInput[]>): ChainMap<ContractVerificationInput[]>;
    protected transferOwnershipOfContracts(chain: ChainName, owner: types.Address, ownables: {
        [key: string]: Ownable;
    }): Promise<ethers.ContractReceipt[]>;
}
//# sourceMappingURL=HyperlaneDeployer.d.ts.map