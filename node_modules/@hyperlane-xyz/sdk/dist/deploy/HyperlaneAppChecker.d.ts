import { Ownable } from '@hyperlane-xyz/core';
import type { types } from '@hyperlane-xyz/utils';
import { HyperlaneApp } from '../HyperlaneApp';
import { MultiProvider } from '../providers/MultiProvider';
import { ChainMap, ChainName } from '../types';
import { CheckerViolation } from './types';
export declare abstract class HyperlaneAppChecker<App extends HyperlaneApp<any>, Config> {
    readonly multiProvider: MultiProvider;
    readonly app: App;
    readonly configMap: ChainMap<Config>;
    readonly violations: CheckerViolation[];
    constructor(multiProvider: MultiProvider, app: App, configMap: ChainMap<Config>);
    abstract checkChain(chain: ChainName): Promise<void>;
    check(): Promise<void[]>;
    addViolation(violation: CheckerViolation): void;
    checkProxiedContracts(chain: ChainName): Promise<void>;
    private removeBytecodeMetadata;
    checkBytecode(chain: ChainName, name: string, address: string, expectedBytecodeHashes: string[], modifyBytecodePriorToHash?: (bytecode: string) => string): Promise<void>;
    ownables(chain: ChainName): Promise<{
        [key: string]: Ownable;
    }>;
    checkOwnership(chain: ChainName, owner: types.Address): Promise<void>;
    expectViolations(violationCounts: Record<string, number>): void;
    expectEmpty(): void;
}
//# sourceMappingURL=HyperlaneAppChecker.d.ts.map