"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDecimalValue = exports.mulBigAndFixed = exports.fixedToBig = exports.bigToFixed = void 0;
const ethers_1 = require("ethers");
/**
 * Converts a BigNumber to a FixedNumber of the format fixed128x18.
 * @param big The BigNumber to convert.
 * @returns A FixedNumber representation of a BigNumber.
 */
function bigToFixed(big) {
    return ethers_1.FixedNumber.from(big.toString());
}
exports.bigToFixed = bigToFixed;
/**
 * Converts a FixedNumber (of any format) to a BigNumber.
 * @param fixed The FixedNumber to convert.
 * @param ceil If true, the ceiling of fixed is used. Otherwise, the floor is used.
 * @returns A BigNumber representation of a FixedNumber.
 */
function fixedToBig(fixed, ceil = false) {
    const fixedAsInteger = ceil ? fixed.ceiling() : fixed.floor();
    return ethers_1.BigNumber.from(fixedAsInteger.toFormat('fixed256x0').toString());
}
exports.fixedToBig = fixedToBig;
/**
 * Multiplies a BigNumber by a FixedNumber, returning the BigNumber product.
 * @param big The BigNumber to multiply.
 * @param fixed The FixedNumber to multiply.
 * @param ceil If true, the ceiling of the product is used. Otherwise, the floor is used.
 * @returns The BigNumber product.
 */
function mulBigAndFixed(big, fixed, ceil = false) {
    // Converts big to a FixedNumber, multiplies it by fixed, and converts the product back
    // to a BigNumber.
    return fixedToBig(fixed.mulUnsafe(bigToFixed(big)), ceil);
}
exports.mulBigAndFixed = mulBigAndFixed;
/**
 * Converts a value with `fromDecimals` decimals to a value with `toDecimals` decimals.
 * Incurs a loss of precision when `fromDecimals` > `toDecimals`.
 * @param value The value to convert.
 * @param fromDecimals The number of decimals `value` has.
 * @param toDecimals The number of decimals to convert `value` to.
 * @returns `value` represented with `toDecimals` decimals.
 */
function convertDecimalValue(value, fromDecimals, toDecimals) {
    if (fromDecimals === toDecimals) {
        return value;
    }
    else if (fromDecimals > toDecimals) {
        return value.div(Math.pow(10, (fromDecimals - toDecimals)));
    }
    else {
        // if (fromDecimals < toDecimals)
        return value.mul(Math.pow(10, (toDecimals - fromDecimals)));
    }
}
exports.convertDecimalValue = convertDecimalValue;
//# sourceMappingURL=number.js.map