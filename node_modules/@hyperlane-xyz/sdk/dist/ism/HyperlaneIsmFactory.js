"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectValidators = exports.moduleMatchesConfig = exports.moduleCanCertainlyVerify = exports.HyperlaneIsmFactory = void 0;
const debug_1 = require("debug");
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneApp_1 = require("../HyperlaneApp");
const environments_1 = require("../consts/environments");
const contracts_1 = require("../contracts");
const contracts_2 = require("./contracts");
const types_1 = require("./types");
class HyperlaneIsmFactory extends HyperlaneApp_1.HyperlaneApp {
    static fromEnvironment(env, multiProvider) {
        const envAddresses = environments_1.hyperlaneEnvironments[env];
        if (!envAddresses) {
            throw new Error(`No addresses found for ${env}`);
        }
        return HyperlaneIsmFactory.fromAddressesMap(envAddresses, multiProvider);
    }
    static fromAddressesMap(addressesMap, multiProvider) {
        const helper = (0, contracts_1.appFromAddressesMapHelper)(addressesMap, contracts_2.ismFactoryFactories, multiProvider);
        return new HyperlaneIsmFactory(helper.contractsMap, helper.multiProvider, (0, debug_1.debug)('hyperlane:IsmFactoryApp'));
    }
    deploy(chain, config, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            if (config.type === types_1.ModuleType.MERKLE_ROOT_MULTISIG ||
                config.type === types_1.ModuleType.MESSAGE_ID_MULTISIG ||
                config.type === types_1.ModuleType.LEGACY_MULTISIG) {
                this.logger(`Deploying Multisig ISM to ${chain} for verifying ${origin}`);
                return this.deployMultisigIsm(chain, config, origin);
            }
            else if (config.type === types_1.ModuleType.ROUTING) {
                this.logger(`Deploying Routing ISM to ${chain} for verifying ${Object.keys(config.domains)}`);
                return this.deployRoutingIsm(chain, config);
            }
            else if (config.type === types_1.ModuleType.AGGREGATION) {
                this.logger(`Deploying Aggregation ISM to ${chain}`);
                return this.deployAggregationIsm(chain, config);
            }
            else {
                throw new Error(`Unsupported ISM type`);
            }
        });
    }
    deployMultisigIsm(chain, config, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(chain);
            let address;
            if (config.type === types_1.ModuleType.LEGACY_MULTISIG) {
                if (process.env.CI !== 'true' &&
                    process.env.ALLOW_LEGACY_MULTISIG_ISM !== 'true') {
                    throw new Error('Legacy multisig ISM is being deprecated, do not deploy');
                }
                const multisig = yield new core_1.LegacyMultisigIsm__factory()
                    .connect(signer)
                    .deploy();
                yield this.multiProvider.handleTx(chain, multisig.deployTransaction);
                const originDomain = this.multiProvider.getDomainId(origin);
                yield this.multiProvider.handleTx(chain, multisig.enrollValidators([originDomain], [config.validators]));
                yield this.multiProvider.handleTx(chain, multisig.setThreshold(originDomain, config.threshold));
                address = multisig.address;
            }
            else {
                const multisigIsmFactory = config.type === types_1.ModuleType.MERKLE_ROOT_MULTISIG
                    ? this.getContracts(chain).merkleRootMultisigIsmFactory
                    : this.getContracts(chain).messageIdMultisigIsmFactory;
                address = yield this.deployMOfNFactory(chain, multisigIsmFactory, config.validators, config.threshold);
            }
            return core_1.IMultisigIsm__factory.connect(address, signer);
        });
    }
    deployRoutingIsm(chain, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(chain);
            const routingIsmFactory = this.getContracts(chain).routingIsmFactory;
            const isms = {};
            for (const origin of Object.keys(config.domains)) {
                const ism = yield this.deploy(chain, config.domains[origin], origin);
                isms[origin] = ism.address;
            }
            const domains = Object.keys(isms).map((chain) => this.multiProvider.getDomainId(chain));
            const submoduleAddresses = Object.values(isms);
            const tx = yield routingIsmFactory.deploy(domains, submoduleAddresses);
            const receipt = yield this.multiProvider.handleTx(chain, tx);
            // TODO: Break this out into a generalized function
            const dispatchLogs = receipt.logs
                .map((log) => {
                try {
                    return routingIsmFactory.interface.parseLog(log);
                }
                catch (e) {
                    return undefined;
                }
            })
                .filter((log) => !!log && log.name === 'ModuleDeployed');
            const moduleAddress = dispatchLogs[0].args['module'];
            const routingIsm = core_1.DomainRoutingIsm__factory.connect(moduleAddress, this.multiProvider.getSigner(chain));
            yield this.multiProvider.handleTx(chain, yield routingIsm.transferOwnership(config.owner));
            const address = dispatchLogs[0].args['module'];
            return core_1.IRoutingIsm__factory.connect(address, signer);
        });
    }
    deployAggregationIsm(chain, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(chain);
            const aggregationIsmFactory = this.getContracts(chain).aggregationIsmFactory;
            const addresses = [];
            for (const module of config.modules) {
                addresses.push((yield this.deploy(chain, module)).address);
            }
            const address = yield this.deployMOfNFactory(chain, aggregationIsmFactory, addresses, config.threshold);
            return core_1.IAggregationIsm__factory.connect(address, signer);
        });
    }
    deployMOfNFactory(chain, factory, values, threshold) {
        return __awaiter(this, void 0, void 0, function* () {
            const sorted = [...values].sort();
            const address = yield factory.getAddress(sorted, threshold);
            const provider = this.multiProvider.getProvider(chain);
            const code = yield provider.getCode(address);
            if (code === '0x') {
                this.logger(`Deploying new ${threshold} of ${values.length} address set to ${chain}`);
                yield factory.deploy(sorted, threshold);
            }
            else {
                this.logger(`Recovered ${threshold} of ${values.length} address set on ${chain}`);
            }
            return address;
        });
    }
}
exports.HyperlaneIsmFactory = HyperlaneIsmFactory;
// Note that this function may return false negatives, but should
// not return false positives.
// This can happen if, for example, the module has sender, recipient, or
// body specific logic, as the sample message used when querying the ISM
// sets all of these to zero.
function moduleCanCertainlyVerify(moduleAddress, multiProvider, origin, destination) {
    return __awaiter(this, void 0, void 0, function* () {
        const message = utils_1.utils.formatMessage(0, 0, multiProvider.getDomainId(origin), ethers_1.ethers.constants.AddressZero, multiProvider.getDomainId(destination), ethers_1.ethers.constants.AddressZero, '0x');
        const provider = multiProvider.getSignerOrProvider(destination);
        const module = core_1.IInterchainSecurityModule__factory.connect(moduleAddress, provider);
        try {
            const moduleType = yield module.moduleType();
            if (moduleType === types_1.ModuleType.MERKLE_ROOT_MULTISIG ||
                moduleType === types_1.ModuleType.LEGACY_MULTISIG ||
                moduleType === types_1.ModuleType.MESSAGE_ID_MULTISIG) {
                const multisigModule = core_1.IMultisigIsm__factory.connect(moduleAddress, provider);
                const [, threshold] = yield multisigModule.validatorsAndThreshold(message);
                return threshold > 0;
            }
            else if (moduleType === types_1.ModuleType.ROUTING) {
                const routingIsm = core_1.IRoutingIsm__factory.connect(moduleAddress, provider);
                const subModule = yield routingIsm.route(message);
                return moduleCanCertainlyVerify(subModule, multiProvider, origin, destination);
            }
            else if (moduleType === types_1.ModuleType.AGGREGATION) {
                const aggregationIsm = core_1.IAggregationIsm__factory.connect(moduleAddress, provider);
                const [subModules, threshold] = yield aggregationIsm.modulesAndThreshold(message);
                let verified = 0;
                for (const subModule of subModules) {
                    const canVerify = yield moduleCanCertainlyVerify(subModule, multiProvider, origin, destination);
                    if (canVerify) {
                        verified += 1;
                    }
                }
                return verified >= threshold;
            }
            else {
                throw new Error(`Unsupported module type: ${moduleType}`);
            }
        }
        catch (e) {
            utils_1.logging.warn(`Error checking module ${moduleAddress}: ${e}`);
            return false;
        }
    });
}
exports.moduleCanCertainlyVerify = moduleCanCertainlyVerify;
function moduleMatchesConfig(chain, moduleAddress, config, multiProvider, contracts) {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = multiProvider.getProvider(chain);
        const module = core_1.IInterchainSecurityModule__factory.connect(moduleAddress, provider);
        const actualType = yield module.moduleType();
        if (actualType !== config.type)
            return false;
        let matches = true;
        switch (config.type) {
            case types_1.ModuleType.MERKLE_ROOT_MULTISIG:
            case types_1.ModuleType.MESSAGE_ID_MULTISIG: {
                // A MultisigIsm matches if validators and threshold match the config
                const expectedAddress = yield contracts.merkleRootMultisigIsmFactory.getAddress(config.validators.sort(), config.threshold);
                matches = utils_1.utils.eqAddress(expectedAddress, module.address);
                break;
            }
            case types_1.ModuleType.LEGACY_MULTISIG: {
                const multisigIsm = core_1.LegacyMultisigIsm__factory.connect(moduleAddress, provider);
                const domain = multiProvider.getDomainId(chain);
                const validators = yield multisigIsm.validators(domain);
                const threshold = yield multisigIsm.threshold(domain);
                matches =
                    config.validators.sort() == validators.sort() &&
                        config.threshold == threshold;
                break;
            }
            case types_1.ModuleType.ROUTING: {
                // A RoutingIsm matches if:
                //   1. The set of domains in the config equals those on-chain
                //   2. The modules for each domain match the config
                // TODO: Check (1)
                const routingIsm = core_1.DomainRoutingIsm__factory.connect(moduleAddress, provider);
                // Check that the RoutingISM owner matches the config
                const owner = yield routingIsm.owner();
                matches = matches && utils_1.utils.eqAddress(owner, config.owner);
                // Recursively check that the submodule for each configured
                // domain matches the submodule config.
                for (const chain of Object.keys(config.domains)) {
                    const subModule = yield routingIsm.modules(multiProvider.getDomainId(chain));
                    const subModuleMatches = yield moduleMatchesConfig(chain, subModule, config.domains[chain], multiProvider, contracts);
                    matches = matches && subModuleMatches;
                }
                break;
            }
            case types_1.ModuleType.AGGREGATION: {
                // An AggregationIsm matches if:
                //   1. The threshold matches the config
                //   2. There is a bijection between on and off-chain configured modules
                const aggregationIsm = core_1.StaticAggregationIsm__factory.connect(moduleAddress, provider);
                const [subModules, threshold] = yield aggregationIsm.modulesAndThreshold('0x');
                matches = matches && threshold === config.threshold;
                matches = matches && subModules.length === config.modules.length;
                const configIndexMatched = new Map();
                for (const subModule of subModules) {
                    const subModuleMatchesConfig = yield Promise.all(config.modules.map((c) => moduleMatchesConfig(chain, subModule, c, multiProvider, contracts)));
                    // The submodule returned by the ISM must match exactly one
                    // entry in the config.
                    const count = subModuleMatchesConfig.filter(Boolean).length;
                    matches = matches && count === 1;
                    // That entry in the config should not have been matched already.
                    subModuleMatchesConfig.forEach((matched, index) => {
                        if (matched) {
                            matches = matches && !configIndexMatched.has(index);
                            configIndexMatched.set(index, true);
                        }
                    });
                }
                break;
            }
            default: {
                throw new Error('Unsupported ModuleType');
            }
        }
        return matches;
    });
}
exports.moduleMatchesConfig = moduleMatchesConfig;
function collectValidators(origin, config) {
    let validators = [];
    if (config.type === types_1.ModuleType.MERKLE_ROOT_MULTISIG ||
        config.type === types_1.ModuleType.MESSAGE_ID_MULTISIG ||
        config.type === types_1.ModuleType.LEGACY_MULTISIG) {
        validators = config.validators;
    }
    else if (config.type === types_1.ModuleType.ROUTING) {
        if (Object.keys(config.domains).includes(origin)) {
            const domainValidators = collectValidators(origin, config.domains[origin]);
            validators = [...domainValidators];
        }
    }
    else if (config.type === types_1.ModuleType.AGGREGATION) {
        const aggregatedValidators = config.modules.map((c) => collectValidators(origin, c));
        aggregatedValidators.forEach((set) => {
            validators = validators.concat([...set]);
        });
    }
    else {
        throw new Error('Unsupported ModuleType');
    }
    return new Set(validators);
}
exports.collectValidators = collectValidators;
//# sourceMappingURL=HyperlaneIsmFactory.js.map