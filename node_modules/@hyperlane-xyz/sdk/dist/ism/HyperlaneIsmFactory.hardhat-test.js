"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const utils_1 = require("@hyperlane-xyz/utils");
const chains_1 = require("../consts/chains");
const MultiProvider_1 = require("../providers/MultiProvider");
const testUtils_1 = require("../test/testUtils");
const HyperlaneIsmFactory_1 = require("./HyperlaneIsmFactory");
const HyperlaneIsmFactoryDeployer_1 = require("./HyperlaneIsmFactoryDeployer");
const types_1 = require("./types");
function randomModuleType() {
    const choices = [
        types_1.ModuleType.AGGREGATION,
        types_1.ModuleType.MERKLE_ROOT_MULTISIG,
        types_1.ModuleType.ROUTING,
    ];
    return choices[(0, testUtils_1.randomInt)(choices.length)];
}
const randomMultisigIsmConfig = (m, n) => {
    const emptyArray = new Array(n).fill(0);
    const validators = emptyArray.map(() => (0, testUtils_1.randomAddress)());
    return {
        type: types_1.ModuleType.MERKLE_ROOT_MULTISIG,
        validators,
        threshold: m,
    };
};
const randomIsmConfig = (depth = 0, maxDepth = 2) => {
    const moduleType = depth == maxDepth ? types_1.ModuleType.MERKLE_ROOT_MULTISIG : randomModuleType();
    if (moduleType === types_1.ModuleType.MERKLE_ROOT_MULTISIG) {
        const n = (0, testUtils_1.randomInt)(5, 1);
        return randomMultisigIsmConfig((0, testUtils_1.randomInt)(n, 1), n);
    }
    else if (moduleType === types_1.ModuleType.ROUTING) {
        const config = {
            type: types_1.ModuleType.ROUTING,
            owner: (0, testUtils_1.randomAddress)(),
            domains: Object.fromEntries(chains_1.TestChains.map((c) => [c, randomIsmConfig(depth + 1)])),
        };
        return config;
    }
    else if (moduleType === types_1.ModuleType.AGGREGATION) {
        const n = (0, testUtils_1.randomInt)(5, 1);
        const modules = new Array(n)
            .fill(0)
            .map(() => randomIsmConfig(depth + 1));
        const config = {
            type: types_1.ModuleType.AGGREGATION,
            threshold: (0, testUtils_1.randomInt)(n, 1),
            modules,
        };
        return config;
    }
    else {
        throw new Error(`Unsupported ISM type: ${moduleType}`);
    }
};
describe('HyperlaneIsmFactory', () => __awaiter(void 0, void 0, void 0, function* () {
    let factory;
    const chain = 'test1';
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        const [signer] = yield hardhat_1.ethers.getSigners();
        const multiProvider = MultiProvider_1.MultiProvider.createTestMultiProvider({ signer });
        const deployer = new HyperlaneIsmFactoryDeployer_1.HyperlaneIsmFactoryDeployer(multiProvider);
        const contracts = yield deployer.deploy([chain]);
        factory = new HyperlaneIsmFactory_1.HyperlaneIsmFactory(contracts, multiProvider);
    }));
    it('deploys a simple ism', () => __awaiter(void 0, void 0, void 0, function* () {
        const config = randomMultisigIsmConfig(3, 5);
        const ism = yield factory.deploy(chain, config);
        const matches = yield (0, HyperlaneIsmFactory_1.moduleMatchesConfig)(chain, ism.address, config, factory.multiProvider, factory.getContracts(chain));
        (0, chai_1.expect)(matches).to.be.true;
    }));
    for (let i = 0; i < 16; i++) {
        it('deploys a random ism config', () => __awaiter(void 0, void 0, void 0, function* () {
            const config = randomIsmConfig();
            let ismAddress;
            try {
                const ism = yield factory.deploy(chain, config);
                ismAddress = ism.address;
            }
            catch (e) {
                (0, utils_1.error)('Failed to deploy random ism config', e);
                (0, utils_1.error)(JSON.stringify(config, null, 2));
                process.exit(1);
            }
            try {
                const matches = yield (0, HyperlaneIsmFactory_1.moduleMatchesConfig)(chain, ismAddress, config, factory.multiProvider, factory.getContracts(chain));
                (0, chai_1.expect)(matches).to.be.true;
            }
            catch (e) {
                (0, utils_1.error)('Failed to match random ism config', e);
                (0, utils_1.error)(JSON.stringify(config, null, 2));
                process.exit(1);
            }
        }));
    }
}));
//# sourceMappingURL=HyperlaneIsmFactory.hardhat-test.js.map