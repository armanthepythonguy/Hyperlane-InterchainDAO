"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneRouterDeployer = void 0;
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const contracts_1 = require("../contracts");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const HyperlaneIsmFactory_1 = require("../ism/HyperlaneIsmFactory");
const objects_1 = require("../utils/objects");
class HyperlaneRouterDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    // The ISM check does not appropriately handle ISMs that have sender,
    // recipient, or body-specific logic. Folks that wish to deploy using
    // such ISMs *may* need to override checkConfig to disable this check.
    checkConfig(configMap) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chains = Object.keys(configMap);
            for (const [chain, config] of Object.entries(configMap)) {
                const signerOrProvider = this.multiProvider.getSignerOrProvider(chain);
                const igp = core_1.IInterchainGasPaymaster__factory.connect(config.interchainGasPaymaster, signerOrProvider);
                const mailbox = core_1.Mailbox__factory.connect(config.mailbox, signerOrProvider);
                const ism = (_a = config.interchainSecurityModule) !== null && _a !== void 0 ? _a : (yield mailbox.defaultIsm());
                const remotes = chains.filter((c) => c !== chain);
                for (const remote of remotes) {
                    // Try to confirm that the IGP supports delivery to all remotes
                    try {
                        yield igp.quoteGasPayment(this.multiProvider.getDomainId(remote), 1);
                    }
                    catch (e) {
                        throw new Error(`The specified or default IGP with address ${igp.address} on ` +
                            `${chain} is not configured to deliver messages to ${remote}, ` +
                            `did you mean to specify a different one?`);
                    }
                    // Try to confirm that the specified or default ISM can verify messages to all remotes
                    const canVerify = yield (0, HyperlaneIsmFactory_1.moduleCanCertainlyVerify)(ism, this.multiProvider, chain, remote);
                    if (!canVerify) {
                        throw new Error(`The specified or default ISM with address ${ism} on ${chain} ` +
                            `cannot verify messages from ${remote}, did you forget to ` +
                            `specify an ISM, or mean to specify a different one?`);
                    }
                }
            }
        });
    }
    initConnectionClients(contractsMap, configMap) {
        const _super = Object.create(null, {
            initConnectionClient: { get: () => super.initConnectionClient }
        });
        return __awaiter(this, void 0, void 0, function* () {
            for (const chain of Object.keys(contractsMap)) {
                const contracts = contractsMap[chain];
                const config = configMap[chain];
                yield _super.initConnectionClient.call(this, chain, this.router(contracts), config);
            }
        });
    }
    enrollRemoteRouters(deployedContractsMap, _, foreignRouters = {}) {
        const _super = Object.create(null, {
            runIfOwner: { get: () => super.runIfOwner }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Enrolling deployed routers with each other (if not already)...`);
            // Make all routers aware of each other.
            // Routers that were deployed.
            const deployedRouters = (0, objects_1.objMap)(deployedContractsMap, (_, contracts) => this.router(contracts).address);
            // All routers, including those that were deployed and those with existing deployments.
            const allRouters = (0, objects_1.objMerge)(deployedRouters, foreignRouters);
            const allChains = Object.keys(allRouters);
            for (const [chain, contracts] of Object.entries(deployedContractsMap)) {
                const allRemoteChains = this.multiProvider
                    .getRemoteChains(chain)
                    .filter((c) => allChains.includes(c));
                const enrollEntries = yield Promise.all(allRemoteChains.map((remote) => __awaiter(this, void 0, void 0, function* () {
                    const remoteDomain = this.multiProvider.getDomainId(remote);
                    const current = yield this.router(contracts).routers(remoteDomain);
                    const expected = utils_1.utils.addressToBytes32(allRouters[remote]);
                    return current !== expected ? [remoteDomain, expected] : undefined;
                })));
                const entries = enrollEntries.filter((entry) => entry !== undefined);
                const domains = entries.map(([id]) => id);
                const addresses = entries.map(([, address]) => address);
                // skip if no enrollments are needed
                if (domains.length === 0) {
                    continue;
                }
                yield _super.runIfOwner.call(this, chain, this.router(contracts), () => __awaiter(this, void 0, void 0, function* () {
                    const chains = domains.map((id) => this.multiProvider.getChainName(id));
                    this.logger(`Enrolling remote routers (${chains.join(', ')}) on ${chain}`);
                    yield this.multiProvider.handleTx(chain, this.router(contracts).enrollRemoteRouters(domains, addresses, this.multiProvider.getTransactionOverrides(chain)));
                }));
            }
        });
    }
    transferOwnership(contractsMap, configMap) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Transferring ownership of ownables...`);
            for (const chain of Object.keys(contractsMap)) {
                const contracts = contractsMap[chain];
                const owner = configMap[chain].owner;
                const ownables = yield (0, contracts_1.filterOwnableContracts)(contracts);
                yield this.transferOwnershipOfContracts(chain, owner, ownables);
            }
        });
    }
    deploy(configMap) {
        const _super = Object.create(null, {
            deploy: { get: () => super.deploy }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // Only deploy on chains that don't have foreign deployments.
            const configMapToDeploy = (0, objects_1.objFilter)(configMap, (_chainName, config) => !config.foreignDeployment);
            // Create a map of chains that have foreign deployments.
            const foreignDeployments = (0, objects_1.objFilter)((0, objects_1.objMap)(configMap, (_, config) => config.foreignDeployment), (_chainName, foreignDeployment) => foreignDeployment !== undefined);
            const deployedContractsMap = yield _super.deploy.call(this, configMapToDeploy);
            yield this.enrollRemoteRouters(deployedContractsMap, configMap, foreignDeployments);
            yield this.initConnectionClients(deployedContractsMap, configMap);
            yield this.transferOwnership(deployedContractsMap, configMap);
            return deployedContractsMap;
        });
    }
}
exports.HyperlaneRouterDeployer = HyperlaneRouterDeployer;
//# sourceMappingURL=HyperlaneRouterDeployer.js.map