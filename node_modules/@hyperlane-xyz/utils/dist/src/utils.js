"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithTimeout = exports.setEquality = exports.symmetricDifference = exports.difference = exports.safelyAccessEnvVar = exports.timeout = exports.isCheckpoint = exports.streamToString = exports.stdDev = exports.mean = exports.sum = exports.median = exports.pollAsync = exports.retryAsync = exports.sleep = exports.domainHash = exports.parseMessage = exports.messageId = exports.formatMessage = exports.formatLegacyMultisigIsmMetadata = exports.parseLegacyMultisigIsmMetadata = exports.formatCallData = exports.bytes32ToAddress = exports.addressToBytes32 = exports.strip0x = exports.ensure0x = exports.eqAddress = exports.deepEquals = exports.assert = exports.exclude = void 0;
const ethers_1 = require("ethers");
function exclude(item, list) {
    return list.filter((i) => i !== item);
}
exports.exclude = exclude;
function assert(predicate, errorMessage) {
    if (!predicate) {
        throw new Error(errorMessage !== null && errorMessage !== void 0 ? errorMessage : 'Error');
    }
}
exports.assert = assert;
function deepEquals(v1, v2) {
    return JSON.stringify(v1) === JSON.stringify(v2);
}
exports.deepEquals = deepEquals;
function eqAddress(a, b) {
    return ethers_1.ethers.utils.getAddress(a) === ethers_1.ethers.utils.getAddress(b);
}
exports.eqAddress = eqAddress;
const ensure0x = (hexstr) => hexstr.startsWith('0x') ? hexstr : `0x${hexstr}`;
exports.ensure0x = ensure0x;
const strip0x = (hexstr) => hexstr.startsWith('0x') ? hexstr.slice(2) : hexstr;
exports.strip0x = strip0x;
function addressToBytes32(address) {
    return ethers_1.ethers.utils
        .hexZeroPad(ethers_1.ethers.utils.hexStripZeros(address), 32)
        .toLowerCase();
}
exports.addressToBytes32 = addressToBytes32;
function bytes32ToAddress(bytes32) {
    return ethers_1.ethers.utils.getAddress(bytes32.slice(-40));
}
exports.bytes32ToAddress = bytes32ToAddress;
function formatCallData(destinationContract, functionName, functionArgs) {
    return destinationContract.interface.encodeFunctionData(functionName, functionArgs);
}
exports.formatCallData = formatCallData;
const parseLegacyMultisigIsmMetadata = (metadata) => {
    const MERKLE_ROOT_OFFSET = 0;
    const MERKLE_INDEX_OFFSET = 32;
    const ORIGIN_MAILBOX_OFFSET = 36;
    const MERKLE_PROOF_OFFSET = 68;
    const THRESHOLD_OFFSET = 1092;
    const SIGNATURES_OFFSET = 1093;
    const SIGNATURE_LENGTH = 65;
    const buf = Buffer.from(ethers_1.utils.arrayify(metadata));
    const checkpointRoot = ethers_1.utils.hexlify(buf.slice(MERKLE_ROOT_OFFSET, MERKLE_INDEX_OFFSET));
    const checkpointIndex = ethers_1.BigNumber.from(ethers_1.utils.hexlify(buf.slice(MERKLE_INDEX_OFFSET, ORIGIN_MAILBOX_OFFSET))).toNumber();
    const originMailbox = ethers_1.utils.hexlify(buf.slice(ORIGIN_MAILBOX_OFFSET, MERKLE_PROOF_OFFSET));
    const parseBytesArray = (start, count, size) => {
        return [...Array(count).keys()].map((i) => ethers_1.utils.hexlify(buf.slice(start + size * i, start + size * (i + 1))));
    };
    const proof = parseBytesArray(MERKLE_PROOF_OFFSET, 32, 32);
    const threshold = ethers_1.BigNumber.from(ethers_1.utils.hexlify(buf.slice(THRESHOLD_OFFSET, SIGNATURES_OFFSET))).toNumber();
    const signatures = parseBytesArray(SIGNATURES_OFFSET, threshold, SIGNATURE_LENGTH);
    const VALIDATORS_OFFSET = SIGNATURES_OFFSET + threshold * SIGNATURE_LENGTH;
    const addressesCount = buf.slice(VALIDATORS_OFFSET).length / 32;
    const validators = parseBytesArray(VALIDATORS_OFFSET, addressesCount, 32);
    return {
        checkpointRoot,
        checkpointIndex,
        originMailbox,
        proof,
        signatures,
        validators,
    };
};
exports.parseLegacyMultisigIsmMetadata = parseLegacyMultisigIsmMetadata;
const formatLegacyMultisigIsmMetadata = (metadata) => {
    return ethers_1.ethers.utils.solidityPack([
        'bytes32',
        'uint32',
        'bytes32',
        'bytes32[32]',
        'uint8',
        'bytes',
        'address[]',
    ], [
        metadata.checkpointRoot,
        metadata.checkpointIndex,
        addressToBytes32(metadata.originMailbox),
        metadata.proof,
        metadata.signatures.length,
        ethers_1.ethers.utils.hexConcat(metadata.signatures),
        metadata.validators,
    ]);
};
exports.formatLegacyMultisigIsmMetadata = formatLegacyMultisigIsmMetadata;
/**
 * JS Implementation of solidity/contracts/libs/Message.sol#formatMessage
 * @returns Hex string of the packed message
 */
const formatMessage = (version, nonce, originDomain, senderAddr, destinationDomain, recipientAddr, body) => {
    senderAddr = addressToBytes32(senderAddr);
    recipientAddr = addressToBytes32(recipientAddr);
    return ethers_1.ethers.utils.solidityPack(['uint8', 'uint32', 'uint32', 'bytes32', 'uint32', 'bytes32', 'bytes'], [
        version,
        nonce,
        originDomain,
        senderAddr,
        destinationDomain,
        recipientAddr,
        body,
    ]);
};
exports.formatMessage = formatMessage;
/**
 * Get ID given message bytes
 * @param message Hex string of the packed message (see formatMessage)
 * @returns Hex string of message id
 */
function messageId(message) {
    return ethers_1.ethers.utils.solidityKeccak256(['bytes'], [message]);
}
exports.messageId = messageId;
/**
 * Parse a serialized Hyperlane message from raw bytes.
 *
 * @param message
 * @returns
 */
function parseMessage(message) {
    const VERSION_OFFSET = 0;
    const NONCE_OFFSET = 1;
    const ORIGIN_OFFSET = 5;
    const SENDER_OFFSET = 9;
    const DESTINATION_OFFSET = 41;
    const RECIPIENT_OFFSET = 45;
    const BODY_OFFSET = 77;
    const buf = Buffer.from(ethers_1.utils.arrayify(message));
    const version = buf.readUint8(VERSION_OFFSET);
    const nonce = buf.readUInt32BE(NONCE_OFFSET);
    const origin = buf.readUInt32BE(ORIGIN_OFFSET);
    const sender = ethers_1.utils.hexlify(buf.slice(SENDER_OFFSET, DESTINATION_OFFSET));
    const destination = buf.readUInt32BE(DESTINATION_OFFSET);
    const recipient = ethers_1.utils.hexlify(buf.slice(RECIPIENT_OFFSET, BODY_OFFSET));
    const body = ethers_1.utils.hexlify(buf.slice(BODY_OFFSET));
    return { version, nonce, origin, sender, destination, recipient, body };
}
exports.parseMessage = parseMessage;
function domainHash(domain, mailbox) {
    return ethers_1.ethers.utils.solidityKeccak256(['uint32', 'bytes32', 'string'], [domain, addressToBytes32(mailbox), 'HYPERLANE']);
}
exports.domainHash = domainHash;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
// Retries an async function if it raises an exception,
// with exponential backoff.
// If all the tries fail it raises the last thrown exception
function retryAsync(runner, attempts = 5, baseRetryMs = 50) {
    return __awaiter(this, void 0, void 0, function* () {
        let saveError;
        for (let i = 0; i < attempts; i++) {
            try {
                const result = yield runner();
                return result;
            }
            catch (error) {
                saveError = error;
                yield sleep(baseRetryMs * Math.pow(2, i));
            }
        }
        throw saveError;
    });
}
exports.retryAsync = retryAsync;
function pollAsync(runner, delayMs = 500, maxAttempts = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
        let attempts = 0;
        let saveError;
        while (!maxAttempts || attempts < maxAttempts) {
            try {
                const ret = yield runner();
                return ret;
            }
            catch (error) {
                saveError = error;
                attempts += 1;
                yield sleep(delayMs);
            }
        }
        throw saveError;
    });
}
exports.pollAsync = pollAsync;
function median(a) {
    const sorted = a.slice().sort();
    const mid = Math.floor(sorted.length / 2);
    const median = sorted.length % 2 == 0 ? (sorted[mid] + sorted[mid + 1]) / 2 : sorted[mid];
    return median;
}
exports.median = median;
function sum(a) {
    return a.reduce((acc, i) => acc + i);
}
exports.sum = sum;
function mean(a) {
    return sum(a) / a.length;
}
exports.mean = mean;
function stdDev(a) {
    const xbar = mean(a);
    const squaredDifferences = a.map((x) => Math.pow(x - xbar, 2));
    return Math.sqrt(mean(squaredDifferences));
}
exports.stdDev = stdDev;
function streamToString(stream) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream
            .setEncoding('utf8')
            .on('data', (chunk) => chunks.push(chunk))
            .on('error', (err) => reject(err))
            .on('end', () => resolve(String.prototype.concat(...chunks)));
    });
}
exports.streamToString = streamToString;
function isCheckpoint(obj) {
    const isValidSignature = typeof obj.signature === 'string'
        ? ethers_1.ethers.utils.isHexString(obj.signature)
        : ethers_1.ethers.utils.isHexString(obj.signature.r) &&
            ethers_1.ethers.utils.isHexString(obj.signature.s) &&
            Number.isSafeInteger(obj.signature.v);
    const isValidRoot = ethers_1.ethers.utils.isHexString(obj.root);
    const isValidIndex = Number.isSafeInteger(obj.index);
    return isValidIndex && isValidRoot && isValidSignature;
}
exports.isCheckpoint = isCheckpoint;
/**
 * Wait up to a given amount of time, and throw an error if the promise does not resolve in time.
 * @param promise The promise to timeout on.
 * @param timeoutMs How long to wait for the promise in milliseconds.
 * @param message The error message if a timeout occurs.
 */
function timeout(promise, timeoutMs, message = 'Timeout reached') {
    if (!timeoutMs || timeoutMs <= 0)
        return promise;
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error(message));
        }, timeoutMs);
        promise.then(resolve).catch(reject);
    });
}
exports.timeout = timeout;
// Should be used instead of referencing process directly in case we don't
// run in node.js
function safelyAccessEnvVar(name) {
    try {
        return process.env[name];
    }
    catch (error) {
        return undefined;
    }
}
exports.safelyAccessEnvVar = safelyAccessEnvVar;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#implementing_basic_set_operations
function difference(a, b) {
    const _difference = new Set(a);
    for (const elem of b) {
        _difference.delete(elem);
    }
    return _difference;
}
exports.difference = difference;
function symmetricDifference(a, b) {
    const _difference = new Set(a);
    for (const elem of b) {
        if (_difference.has(elem)) {
            _difference.delete(elem);
        }
        else {
            _difference.add(elem);
        }
    }
    return _difference;
}
exports.symmetricDifference = symmetricDifference;
function setEquality(a, b) {
    return symmetricDifference(a, b).size === 0;
}
exports.setEquality = setEquality;
function runWithTimeout(timeoutMs, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        let timeout;
        const timeoutProm = new Promise((_, reject) => (timeout = setTimeout(() => reject(new Error(`Timed out in ${timeoutMs}ms.`)), timeoutMs)));
        const ret = yield Promise.race([callback(), timeoutProm]);
        // @ts-ignore timeout gets set immediately by the promise constructor
        clearTimeout(timeout);
        return ret;
    });
}
exports.runWithTimeout = runWithTimeout;
//# sourceMappingURL=utils.js.map