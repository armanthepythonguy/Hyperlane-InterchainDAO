/// <reference types="node" />
import { BigNumber, ethers } from 'ethers';
import { Address, Checkpoint, Domain, HexString, ParsedLegacyMultisigIsmMetadata, ParsedMessage } from './types';
export declare function exclude<T>(item: T, list: T[]): T[];
export declare function assert(predicate: any, errorMessage?: string): void;
export declare function deepEquals(v1: any, v2: any): boolean;
export declare function eqAddress(a: string, b: string): boolean;
export declare const ensure0x: (hexstr: string) => string;
export declare const strip0x: (hexstr: string) => string;
export declare function addressToBytes32(address: Address): string;
export declare function bytes32ToAddress(bytes32: string): Address;
export declare function formatCallData<C extends ethers.Contract, I extends Parameters<C['interface']['encodeFunctionData']>>(destinationContract: C, functionName: I[0], functionArgs: I[1]): string;
export declare const parseLegacyMultisigIsmMetadata: (metadata: string) => ParsedLegacyMultisigIsmMetadata;
export declare const formatLegacyMultisigIsmMetadata: (metadata: ParsedLegacyMultisigIsmMetadata) => string;
/**
 * JS Implementation of solidity/contracts/libs/Message.sol#formatMessage
 * @returns Hex string of the packed message
 */
export declare const formatMessage: (version: number | BigNumber, nonce: number | BigNumber, originDomain: Domain, senderAddr: Address, destinationDomain: Domain, recipientAddr: Address, body: HexString) => HexString;
/**
 * Get ID given message bytes
 * @param message Hex string of the packed message (see formatMessage)
 * @returns Hex string of message id
 */
export declare function messageId(message: HexString): HexString;
/**
 * Parse a serialized Hyperlane message from raw bytes.
 *
 * @param message
 * @returns
 */
export declare function parseMessage(message: string): ParsedMessage;
export declare function domainHash(domain: number, mailbox: string): string;
export declare function sleep(ms: number): Promise<void>;
export declare function retryAsync<T>(runner: () => T, attempts?: number, baseRetryMs?: number): Promise<T>;
export declare function pollAsync<T>(runner: () => Promise<T>, delayMs?: number, maxAttempts?: number | undefined): Promise<T>;
export declare function median(a: number[]): number;
export declare function sum(a: number[]): number;
export declare function mean(a: number[]): number;
export declare function stdDev(a: number[]): number;
export declare function streamToString(stream: NodeJS.ReadableStream): Promise<string>;
export declare function isCheckpoint(obj: any): obj is Checkpoint;
/**
 * Wait up to a given amount of time, and throw an error if the promise does not resolve in time.
 * @param promise The promise to timeout on.
 * @param timeoutMs How long to wait for the promise in milliseconds.
 * @param message The error message if a timeout occurs.
 */
export declare function timeout<T>(promise: Promise<T>, timeoutMs?: number, message?: string): Promise<T>;
export declare function safelyAccessEnvVar(name: string): string | undefined;
export declare function difference<T>(a: Set<T>, b: Set<T>): Set<T>;
export declare function symmetricDifference<T>(a: Set<T>, b: Set<T>): Set<T>;
export declare function setEquality<T>(a: Set<T>, b: Set<T>): boolean;
export declare function runWithTimeout<T>(timeoutMs: number, callback: () => Promise<T>): Promise<T | void>;
//# sourceMappingURL=utils.d.ts.map